#!/bin/bash

# Enhanced Claude Task Runner - Lyra-Dev powered context-aware wrapper for Claude Code
# Features:
#   - Two-stage Claude execution: prompt-builder â†’ executor (eliminates meta-prompt issues)
#   - Lyra-Dev 4-D methodology for optimized prompt generation  
#   - CRITICAL: Status verification protocol to detect false completion claims
#   - AUDIT-AND-IMPLEMENT workflow: Claude audits and fixes gaps in one run
#   - Always comments audit results on issues/PRs for full transparency
#   - Smart PR creation: only when actual code changes are made
#   - Graceful handling of "already complete" cases (auto-closes, no unnecessary PRs)
#   - Single task or range processing (e.g., 230-250)
#   - Automatic branch creation for each task
#   - Configurable timeout between tasks for API rate limiting
#   - Interactive or headless mode support
#   - Project-aware prompts using CLAUDE.md context
#   - Gap analysis: focuses on actual missing pieces, not claimed completions
#   - Robust retry logic with exponential backoff for API limits
#
# Workflow: 
#   Issues: meta-prompt â†’ optimized prompt â†’ audit â†’ implement gaps â†’ comment â†’ PR (if changes exist)
#   PR Reviews: direct prompt â†’ review analysis â†’ gh pr comment (no branches/PRs/separate comments)
#
# Usage:
#   claude-task <issue_number> [options]                                     - Audit and implement a single task
#   claude-task <start_issue>-<end_issue> [options]                         - Audit and implement a range of tasks
#   claude-task --review-pr <pr_number> [options]                           - Review a single PR (read-only analysis)
#   claude-task --review-pr <start_pr>-<end_pr> [options]                   - Review a range of PRs (read-only analysis)
#   --auto-pr-review flag: Automatically review PRs after issue implementation
#
# Requirements:
#   - Must be run from a directory containing CLAUDE.md
#   - Must be in a git repository with GitHub remote

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_range() {
    echo -e "${CYAN}[RANGE]${NC} $1"
}

# Check if required tools are available
check_dependencies() {
    local prompt_only="$1"
    local missing_tools=()

    if ! command -v gh &> /dev/null; then
        missing_tools+=("gh (GitHub CLI)")
    fi

    if ! command -v jq &> /dev/null; then
        missing_tools+=("jq (JSON processor)")
    fi

    # Only require coder command if not in prompt-only mode
    if [ "$prompt_only" != "true" ]; then
        if [ "$CODER" = "codex" ]; then
            if ! command -v codex &> /dev/null; then
                missing_tools+=("codex (Codex CLI)")
            fi
        else
            if ! command -v claude &> /dev/null; then
                missing_tools+=("claude (Claude Code)")
            fi
        fi
    fi

    if ! command -v git &> /dev/null; then
        missing_tools+=("git")
    fi

    if [ ${#missing_tools[@]} -ne 0 ]; then
        log_error "Missing required tools:"
        printf '%s\n' "${missing_tools[@]}"
        echo ""
        echo "Please install the missing tools and try again."
        exit 1
    fi
}

# Validate environment
validate_environment() {
    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        log_error "This script must be run from within a git repository."
        exit 1
    fi

    # Check if CLAUDE.md exists
    if [ ! -f "CLAUDE.md" ]; then
        log_error "CLAUDE.md not found in current directory."
        log_error "This script must be run from a directory containing CLAUDE.md"
        exit 1
    fi

    log_success "Environment validation passed"
}

# Extract repository information from git config
get_repo_info() {
    local git_url
    git_url=$(git config --get remote.origin.url 2>/dev/null || {
        log_error "Could not find remote.origin.url in git config"
        exit 1
    })

    # Extract owner and repo from URL (handles both SSH and HTTPS)
    if [[ $git_url =~ github\.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
        REPO_OWNER="${BASH_REMATCH[1]}"
        REPO_NAME="${BASH_REMATCH[2]}"
        REPO_NAME="${REPO_NAME%.git}"  # Remove .git suffix if present
    else
        log_error "Could not parse GitHub repository from git URL: $git_url"
        exit 1
    fi

    log_info "Repository: ${REPO_OWNER}/${REPO_NAME}"
}

# Workspace hygiene - clean state before each task
workspace_hygiene() {
    log_info "Cleaning workspace..."
    git reset --hard || true
    git clean -fd || true
    
    # Ensure we're on main/master
    local main_branch
    if git show-ref --verify --quiet refs/heads/main; then
        main_branch="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        main_branch="master"
    else
        log_warning "Could not find main or master branch"
        return 0
    fi
    
    git checkout "$main_branch" || true
    git pull origin "$main_branch" || true
    log_success "Workspace cleaned and updated"
}

# Prompt user for confirmation before workspace cleanup
confirm_workspace_cleanup() {
    # Skip prompt in non-interactive environments
    if [ ! -t 0 ] || [ ! -t 1 ]; then
        log_info "Non-interactive environment detected, proceeding with workspace cleanup"
        return 0
    fi
    
    # Skip prompt if CLAUDE_TASKER_AUTO_CLEANUP is set (for CI/automation)
    if [ -n "$CLAUDE_TASKER_AUTO_CLEANUP" ]; then
        log_info "Auto-cleanup enabled via CLAUDE_TASKER_AUTO_CLEANUP, proceeding with workspace cleanup"
        return 0
    fi
    
    log_warning "âš ï¸  WORKSPACE CLEANUP REQUIRED"
    echo "This operation will:"
    echo "  â€¢ Remove all uncommitted changes (git reset --hard)"
    echo "  â€¢ Delete all untracked files and directories (git clean -fd)" 
    echo "  â€¢ Switch to main branch and pull latest changes"
    echo ""
    echo "Any local work that hasn't been committed and pushed will be PERMANENTLY LOST."
    echo ""
    
    local response
    while true; do
        read -p "Do you want to proceed with workspace cleanup? [y/N]: " response
        case "$response" in
            [Yy]|[Yy][Ee][Ss])
                log_info "User confirmed workspace cleanup"
                return 0
                ;;
            [Nn]|[Nn][Oo]|"")
                log_info "User declined workspace cleanup"
                echo "Operation cancelled. To proceed:"
                echo "  â€¢ Commit your changes: git add . && git commit -m 'your message'"
                echo "  â€¢ Or set CLAUDE_TASKER_AUTO_CLEANUP=1 to skip this prompt"
                return 1
                ;;
            *)
                echo "Please answer 'y' for yes or 'n' for no."
                ;;
        esac
    done
}

# Always commit and push changes (simplified - only called when changes exist)
commit_and_push() {
    local branch_name="$1"
    local number="$2"  # issue/PR number for reference
    local mode="$3"    # implement | review
    
    log_info "=== COMMIT AND PUSH DEBUG FOR ${mode} #${number} ==="
    log_info "Branch: ${branch_name}"
    log_info "Current branch: $(git branch --show-current)"
    
    # Verify we're on the expected branch
    if [ "$(git branch --show-current)" != "$branch_name" ]; then
        log_warning "WARNING: Expected to be on branch '${branch_name}' but on '$(git branch --show-current)'"
    fi
    
    log_info "Git status before staging:"
    git status --porcelain | head -10 | while read status_line; do
        log_info "  ${status_line}"
    done
    
    # Stage all changes
    log_info "Staging all changes with 'git add -A'..."
    git add -A
    
    log_info "Git status after staging:"
    git status --porcelain | head -10 | while read status_line; do
        log_info "  ${status_line}"
    done
    
    # Check what's actually staged
    if git diff --cached --quiet; then
        log_warning "No staged changes found - nothing to commit!"
        return 0
    fi
    
    # Commit (we know changes exist since this is only called after diff check)
    local commit_msg="ðŸ¤– ${branch_name}: automated changes from Claude"
    log_info "Committing with message: '${commit_msg}'"
    if git commit -m "$commit_msg"; then
        log_success "Changes committed successfully"
        local commit_hash=$(git rev-parse HEAD)
        log_info "Commit hash: ${commit_hash}"
    else
        log_error "Failed to commit changes"
        return 1
    fi
    
    # Push the branch
    log_info "Pushing branch '${branch_name}' to origin..."
    if git push -u origin "$branch_name"; then
        log_success "Branch pushed to origin: ${branch_name}"
        local remote_url
        remote_url=$(git remote get-url origin)
        log_info "Remote URL: ${remote_url}"
    else
        log_error "Failed to push branch: ${branch_name}"
        return 1
    fi
    
    log_info "=== END COMMIT AND PUSH DEBUG ==="
    return 0
}

# Merge Claude's output with PR template if available
# Helper function to detect PR template files
detect_pr_template() {
    for template_path in ".github/pull_request_template.md" ".github/PULL_REQUEST_TEMPLATE.md" "pull_request_template.md"; do
        if [ -f "$template_path" ]; then
            echo "$template_path"
            return 0
        fi
    done
    return 1
}


# Intelligent LLM-powered PR body generation
generate_intelligent_pr_body() {
    local claude_output_file="$1"
    local issue_number="$2"
    local mode="$3"
    
    log_info "Generating intelligent PR body using LLM synthesis..."
    
    # Create secure temporary file for output
    local output_file
    output_file=$(mktemp) || { log_error "Failed to create temporary file"; return 1; }
    
    # Validate Claude output file exists and is readable
    if [ ! -f "$claude_output_file" ] || [ ! -r "$claude_output_file" ]; then
        log_error "Claude output file not found or not readable: $claude_output_file"
        rm -f "$output_file" 2>/dev/null
        return 1
    fi
    
    # Gather all context for intelligent synthesis
    log_info "Collecting context: git diff, issue details, template structure..."
    
    # Get git diff from main branch
    local git_diff
    local main_branch="main"
    if ! git show-ref --verify --quiet refs/heads/main; then
        main_branch="master"
    fi
    git_diff=$(git diff "${main_branch}...HEAD" 2>/dev/null || echo "No diff available")
    
    # Get issue details if in implement mode
    local issue_details=""
    if [ "$mode" = "implement" ] && [ -n "$issue_number" ]; then
        issue_details=$(gh issue view "$issue_number" --json body,title,labels 2>/dev/null || echo '{"title":"Issue not found","body":"","labels":[]}')
    fi
    
    # Get Claude's analysis
    local claude_analysis
    claude_analysis=$(cat "$claude_output_file" 2>/dev/null || echo "No analysis available")
    
    # Get PR template structure if available
    local template_content=""
    local template_file
    if template_file=$(detect_pr_template); then
        template_content=$(cat "$template_file" 2>/dev/null || echo "")
    fi
    
    # Get repository context (recent commits for style reference)
    local recent_commits
    recent_commits=$(git log --oneline -5 2>/dev/null || echo "No commit history available")
    
    # Check if llm tool is available and functional
    if ! command -v llm >/dev/null 2>&1; then
        log_warning "LLM tool not available, using original Claude output"
        echo "$claude_output_file"
        return 0
    fi
    
    # Create comprehensive LLM prompt
    log_info "Synthesizing intelligent PR body with LLM..."
    
    # Use llm to generate intelligent PR body
    cat > "$output_file" << 'EOF'
# LLM PROMPT FOR INTELLIGENT PR BODY GENERATION

You are an expert software engineer creating an exceptional GitHub Pull Request description. You have access to:

1. **Git Diff**: The actual code changes made
2. **Original Issue**: The problem being solved  
3. **Implementation Analysis**: Claude's technical analysis of what was accomplished
4. **PR Template**: The expected structure and sections
5. **Repository Context**: Recent commit patterns for style consistency

## Your Task:
Create a comprehensive, professional PR body that:

**FOLLOWS TEMPLATE STRUCTURE** but goes beyond it when beneficial
**SYNTHESIZES ALL CONTEXT** into a cohesive narrative  
**HIGHLIGHTS KEY TECHNICAL DETAILS** that matter for review
**INCLUDES IMPLEMENTATION APPROACH** based on actual code changes
**ADDRESSES TESTING & SECURITY** implications when relevant
**MAINTAINS PROFESSIONAL TONE** consistent with repository style

## Key Guidelines:
- Use the template sections as your foundation
- Extract meaningful implementation details from the diff
- Synthesize Claude's analysis with actual changes  
- Include technical considerations beyond template requirements
- Ensure accuracy - only claim what was actually implemented
- Make it reviewer-friendly with clear structure and actionable information
- Include any breaking changes, migration notes, or special considerations

## Critical Constraint:
**KEEP OUTPUT CONCISE** - The final PR body must be under 10,000 characters total. If the context data is extensive, intelligently summarize the most important points rather than including everything. Focus on:
1. Key changes made (not every detail)
2. Most important technical decisions
3. Critical testing considerations
4. Essential reviewer information

## Output Format:
Generate ONLY the final PR body markdown - no explanations or meta-commentary.

EOF
    
    # Add context data to the prompt - let LLM handle intelligent summarization
    # Log input sizes for debugging
    log_info "Context sizes - Diff: ${#git_diff}, Analysis: ${#claude_analysis}, Template: ${#template_content}, Commits: ${#recent_commits}"
    
    cat >> "$output_file" << EOF

## CONTEXT DATA:
NOTE: This context may be extensive. Please intelligently summarize and extract only the most important information for the PR body, keeping the final output under 10,000 characters.

### Git Diff:
\`\`\`diff
$git_diff
\`\`\`

### Issue Details:
\`\`\`json
$issue_details
\`\`\`

### Claude's Implementation Analysis:
\`\`\`
$claude_analysis
\`\`\`

### PR Template Structure:
\`\`\`markdown
$template_content
\`\`\`

### Recent Commits (for style reference):
\`\`\`
$recent_commits
\`\`\`

### Mode: $mode
### Issue Number: $issue_number

---

Generate the intelligent PR body now (remember: keep under 10,000 characters total):
EOF
    
    # Generate the intelligent PR body using llm with better error handling
    local intelligent_body
    local llm_error_log="/tmp/llm-pr-error-$$.log"
    
    # Check final prompt file size before processing
    local final_prompt_size=$(wc -c < "$output_file" 2>/dev/null || echo "0")
    log_info "Final LLM prompt size: ${final_prompt_size} bytes"
    
    if [ "$final_prompt_size" -gt 500000 ]; then
        log_warning "LLM prompt is very large (${final_prompt_size} bytes) - this may cause issues"
    fi
    
    intelligent_body=$(llm prompt -f "$output_file" 2>"$llm_error_log")
    local llm_exit_code=$?
    
    # Check for LLM execution errors
    if [ $llm_exit_code -ne 0 ] || [ -z "$intelligent_body" ] || [ "$intelligent_body" = "null" ]; then
        if [ -s "$llm_error_log" ]; then
            log_warning "LLM generation failed with error: $(cat "$llm_error_log")"
        else
            log_warning "LLM generation failed with exit code $llm_exit_code"
        fi
        log_warning "Using original Claude output instead of LLM-enhanced version"
        rm -f "$output_file" "$llm_error_log" 2>/dev/null
        echo "$claude_output_file"
        return 0
    fi
    
    # Write the intelligent output to the file
    echo "$intelligent_body" > "$output_file"
    
    # Validate output was created successfully and check size
    if [ ! -s "$output_file" ]; then
        log_error "Failed to generate intelligent PR body"
        rm -f "$output_file" "$llm_error_log" 2>/dev/null
        return 1
    fi
    
    local output_size=${#intelligent_body}
    if [ "$output_size" -gt 15000 ]; then
        log_warning "Generated PR body is quite large (${output_size} characters) - this might cause issues"
        # Don't fail, just warn - let GitHub handle the limit
    fi
    
    # Clean up error log
    rm -f "$llm_error_log" 2>/dev/null
    
    log_success "Generated intelligent PR body: $output_file (${output_size} characters)"
    echo "$output_file"
}


# Create or update a PR (simplified - only called when changes exist)
ensure_pr() {
    local number="$1"        # issue or PR original number
    local branch="$2"        # branch_name
    local mode="$3"          # implement | review
    local body_file="$4"     # temp file containing Claude's output
    
    log_info "=== PR CREATION/UPDATE DEBUG FOR ${mode} #${number} ==="
    log_info "Branch: ${branch}"
    log_info "Body file: ${body_file}"
    
    # Merge Claude's output with PR template if available
    local final_body_file
    final_body_file=$(generate_intelligent_pr_body "$body_file" "$number" "$mode")
    log_info "Using body file: ${final_body_file}"
    
    # Check if PR already exists for this branch
    log_info "Checking if PR already exists for branch ${branch}..."
    if gh pr view "$branch" --repo "${REPO_OWNER}/${REPO_NAME}" &>/dev/null; then
        log_info "FOUND EXISTING PR for branch ${branch} - updating body..."
        local existing_pr_info
        existing_pr_info=$(gh pr view "$branch" --repo "${REPO_OWNER}/${REPO_NAME}" --json number,title,url)
        log_info "Existing PR details: $existing_pr_info"
        
        # Extract PR number for return
        local existing_pr_number
        existing_pr_number=$(echo "$existing_pr_info" | jq -r '.number' 2>/dev/null || echo "")
        
        if gh pr edit "$branch" --repo "${REPO_OWNER}/${REPO_NAME}" --body-file "$final_body_file"; then
            log_success "PR updated for branch: ${branch}"
        else
            log_warning "Failed to update PR body for branch: ${branch}"
        fi
        
        # Return PR number for tracking
        echo "$existing_pr_number"
    else
        log_info "No existing PR found for branch ${branch} - creating new PR..."
        
        # Check if there are any existing PRs for this issue
        if [ "$mode" = "implement" ]; then
            log_info "Checking for other PRs that might be related to issue #${number}..."
            local related_prs
            related_prs=$(gh pr list --repo "${REPO_OWNER}/${REPO_NAME}" --search "#${number}" --json number,title,headRefName --limit 5)
            if [ "$related_prs" != "[]" ] && [ -n "$related_prs" ]; then
                log_warning "FOUND OTHER PRs THAT MENTION ISSUE #${number}:"
                echo "$related_prs" | jq -r '.[] | "  PR #\(.number): \(.title) (branch: \(.headRefName))"' 2>/dev/null || echo "$related_prs"
                log_warning "*** CREATING ANOTHER PR FOR THE SAME ISSUE - IS THIS INTENDED? ***"
            fi
        fi
        
        local title
        if [ "$mode" = "implement" ]; then
            title="ðŸ¤– Issue #$number â€“ automated implementation"
        else
            title="ðŸ¤– PR #$number â€“ automated review"
        fi
        
        local main_branch="main"
        if ! git show-ref --verify --quiet refs/heads/main; then
            main_branch="master"
        fi
        
        log_info "Creating PR: title='${title}', base='${main_branch}', head='${branch}'"
        if gh pr create --repo "${REPO_OWNER}/${REPO_NAME}" --base "$main_branch" --head "$branch" \
                        --title "$title" --body-file "$final_body_file" >/dev/null; then
            local new_pr_info
            new_pr_info=$(gh pr view "$branch" --repo "${REPO_OWNER}/${REPO_NAME}" --json number,url)
            local new_pr_url
            new_pr_url=$(echo "$new_pr_info" | jq -r '.url' 2>/dev/null || echo "")
            local new_pr_number
            new_pr_number=$(echo "$new_pr_info" | jq -r '.number' 2>/dev/null || echo "")
            
            log_success "NEW PR created for branch: ${branch}"
            log_success "PR URL: ${new_pr_url}"
            
            # Return PR number for tracking
            echo "$new_pr_number"
        else
            log_error "Failed to create PR for branch: ${branch}"
            return 1
        fi
    fi
    
    # Clean up temporary template file if it was created
    if [ "$final_body_file" != "$body_file" ] && [ -f "$final_body_file" ]; then
        if rm -f "$final_body_file" 2>/dev/null; then
            log_info "Cleaned up temporary PR template file: $final_body_file"
        else
            log_warning "Failed to clean up temporary PR template file: $final_body_file"
        fi
    fi
    
    log_info "=== END PR DEBUG ==="
}

# Always comment on the issue or PR
issue_comment() {
    local number="$1"
    local body_file="$2"
    local mode="$3"  # implement | review
    
    log_info "Adding comment to ${mode} #${number}..."
    
    # Debug: check if body file exists and its size
    if [ ! -f "$body_file" ]; then
        log_error "Body file $body_file does not exist"
        return 1
    fi
    
    local file_size=$(wc -c < "$body_file" 2>/dev/null || echo "0")
    log_info "Body file size: $file_size bytes"
    
    if [ "$file_size" -eq 0 ]; then
        log_warning "Body file is empty - this will result in truncated comment"
        echo "## Debug Info" > /tmp/empty-comment-debug.md
        echo "The audit output file was empty. This indicates Claude execution may have failed." >> /tmp/empty-comment-debug.md
        echo "Check the logs for Claude execution errors." >> /tmp/empty-comment-debug.md
        body_file="/tmp/empty-comment-debug.md"
        file_size=$(wc -c < "$body_file")
    fi
    
    # Create a comment with summary (compatible capitalization)
    local mode_cap
    case $mode in
        implement) mode_cap="Implementation" ;;
        review) mode_cap="Review" ;;
        *) mode_cap="Task" ;;
    esac
    
    local comment_file="/tmp/comment-${number}.md"
    {
        echo "ðŸ¤– **Automated ${mode_cap} Complete**"
        echo ""
        echo "**Branch**: \`$(git branch --show-current)\`"
        echo "**Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo ""
        echo "## Analysis"
        echo ""
        
        # For PR reviews: include FULL analysis (no truncation)
        # For implementations: show key audit results with reasonable limit
        if [ "$mode" = "review" ]; then
            # PR reviews need full analysis - no truncation!
            cat "$body_file"
        else
            # Implementation mode: show first 3000 chars but always include audit conclusions
            local file_size=$(wc -c < "$body_file")
            if [ $file_size -le 3000 ]; then
                # Small enough, show everything
                cat "$body_file"
            else
                # Show first part and look for key audit sections
                head -c 2500 "$body_file"
                echo ""
                echo "..."
                echo ""
                # Always include status/conclusion sections if they exist
                if grep -q -i "STATUS\|CONCLUSION\|RESULT\|COMPLETE\|AUDIT.*SUMMARY\|NO.*CHANGES.*NEEDED\|ALREADY.*COMPLETE" "$body_file"; then
                    echo "## Key Findings"
                    grep -A 5 -i "STATUS\|CONCLUSION\|RESULT\|COMPLETE\|AUDIT.*SUMMARY\|NO.*CHANGES.*NEEDED\|ALREADY.*COMPLETE" "$body_file" | tail -10
                fi
                echo ""
                echo "... (full details in branch: \`$(git branch --show-current)\`)"
            fi
        fi
    } > "$comment_file"
    
    if [ "$mode" = "implement" ]; then
        if gh issue comment "$number" --repo "${REPO_OWNER}/${REPO_NAME}" --body-file "$comment_file"; then
            log_success "Comment added to issue #${number}"
        else
            log_warning "Failed to add comment to issue #${number}"
        fi
    else
        if gh pr comment "$number" --repo "${REPO_OWNER}/${REPO_NAME}" --body-file "$comment_file"; then
            log_success "Comment added to PR #${number}"
        else
            log_warning "Failed to add comment to PR #${number}"
        fi
    fi
    
    rm -f "$comment_file"
}

# Optionally close issue if completely implemented
# TODO: Implement proper issue closing logic based on PR approval status
# Issues should only be closed when:
# 1. PR has been created and merged, OR
# 2. PR has been reviewed and approved by maintainer
# Current auto-close logic removed due to false positive issues
check_pr_approval_and_close_issue() {
    local number="$1"
    local pr_number="$2"
    
    # TODO: Implement logic to check PR approval status via GitHub API
    # gh pr view $pr_number --json reviewDecision,mergeStateStatus
    # Only close issue if PR is approved/merged
    log_info "TODO: Check PR #${pr_number} approval status before closing issue #${number}"
    log_info "For now, leaving issue #${number} open for manual review"
}

# Execute Claude with retry logic for rate limiting
# Helper function for timestamps
_ts() { 
    date +%s 
}

# Check if branch has no commits ahead of main
branch_is_empty() {
    # returns 0 (true) if the branch has no commits ahead of main
    git rev-list --count origin/main..HEAD >/dev/null 2>&1
    [ $? -eq 0 ] && [ "$(git rev-list --count origin/main..HEAD)" -eq 0 ]
}

# Enhanced logging for debugging branch/PR issues
debug_existing_state() {
    local number="$1"
    local mode="$2"
    
    log_info "=== DEBUGGING EXISTING STATE FOR ${mode} #${number} ==="
    
    if [ "$mode" = "implement" ]; then
        # Check for existing PRs linked to this issue
        log_info "Checking for existing PRs linked to issue #${number}..."
        local linked_prs
        linked_prs=$(gh pr list --repo "${REPO_OWNER}/${REPO_NAME}" --search "closes:#${number} OR fixes:#${number} OR issue #${number}" --json number,title,headRefName,state 2>/dev/null || echo "[]")
        
        if [ "$linked_prs" != "[]" ] && [ -n "$linked_prs" ]; then
            log_warning "FOUND EXISTING PRs FOR ISSUE #${number}:"
            echo "$linked_prs" | jq -r '.[] | "  PR #\(.number): \(.title) (branch: \(.headRefName), state: \(.state))"' 2>/dev/null || echo "$linked_prs"
        else
            log_info "No existing PRs found for issue #${number}"
        fi
        
        # Check for existing branches that might be related
        log_info "Checking for existing branches related to issue #${number}..."
        local related_branches
        related_branches=$(git branch -r | grep -E "issue-${number}|${number}" | head -5 || true)
        
        if [ -n "$related_branches" ]; then
            log_warning "FOUND EXISTING BRANCHES RELATED TO ISSUE #${number}:"
            echo "$related_branches" | while read branch; do
                log_warning "  ${branch}"
            done
        else
            log_info "No existing branches found for issue #${number}"
        fi
    fi
    
    # Show current branch and status
    log_info "Current branch: $(git branch --show-current)"
    log_info "Current working tree status:"
    if git diff --quiet; then
        log_info "  Working tree is clean"
    else
        log_warning "  Working tree has uncommitted changes!"
        git status --porcelain | head -10 | while read status_line; do
            log_warning "    ${status_line}"
        done
    fi
    
    log_info "=== END DEBUGGING STATE ==="
}

# Run Claude and capture clean output to file while showing colors on screen
run_claude() {
    local prompt="$1"
    local outfile="$2" 
    local mode="$3"  # mode: interactive|headless
    
    # Convert mode to boolean for execute_coder
    local interactive_flag=$([[ $mode == "interactive" ]] && echo "true" || echo "false")
    
    # Execute using the configured coder (claude or codex)
    if execute_coder "$prompt" "$outfile" "$interactive_flag"; then
        # Verify output was written
        if [ ! -s "$outfile" ]; then
            echo "[ERROR] Output file is empty after $CODER execution" >&2
            return 1
        fi
        
        log_info "$CODER output captured ($(wc -c < "$outfile") bytes)"
        return 0
    else
        echo "[ERROR] $CODER execution failed" >&2
        return 1
    fi
}

# ---------- Prompt-builder helpers ----------

# (a) run LLM for meta-prompt optimization (replaces Claude for large prompts)
build_prompt_with_llm() {
    local meta_prompt="$1"
    local json_out="$2"
    local text_out="$3"

    log_info "Building prompt with LLM (input: ${#meta_prompt} chars)..."
    
    # Save prompt for debugging
    local prompt_file="/tmp/llm-prompt-${RANDOM}.txt"
    printf '%s\n' "$meta_prompt" > "$prompt_file"
    local prompt_size=$(wc -c < "$prompt_file")
    log_info "LLM meta-prompt saved to: $prompt_file (${prompt_size} bytes)"
    
    # Create error log file
    local error_log="/tmp/llm-error-${RANDOM}.log"
    local output_log="/tmp/llm-output-${RANDOM}.log"
    
    # Test if llm command exists and is executable
    if ! command -v llm &> /dev/null; then
        log_error "LLM command not found in PATH"
        return 1
    fi
    
    # Show the exact command being run
    log_info "Executing: llm (default model: gpt-4o-mini)"
    
    # Use LLM with larger context capacity than Claude
    cat "$prompt_file" | llm 2>"$error_log" \
        | tee "$output_log" > "$text_out"
    
    # Log output file sizes
    local output_size=$(wc -c < "$text_out" 2>/dev/null || echo "0")
    log_info "LLM output size: ${output_size} bytes"
    
    # Create a fake JSON output for compatibility (LLM outputs text directly)
    cat > "$json_out" << EOF
{
  "type": "result",
  "subtype": "success", 
  "is_error": false,
  "result": "$(cat "$text_out" | sed 's/"/\\"/g' | tr '\n' ' ')"
}
EOF
    
    # Clean up temp file
    rm -f "$prompt_file"

    # Check for command failures
    local exit_code=$?
    if [ $exit_code -ne 0 ]; then
        echo "[ERROR] LLM command failed with exit code $exit_code" >&2
        if [ -f "$error_log" ] && [ -s "$error_log" ]; then
            echo "[ERROR] LLM stderr: $(cat "$error_log")" >&2
        else
            echo "[ERROR] No error output from LLM (stderr was empty)" >&2
        fi
        rm -f "$error_log"
        return 1
    fi

    # Debug: Check what we got from LLM
    if [ ! -f "$json_out" ]; then
        echo "[ERROR] No JSON output file created" >&2
        return 1
    fi
    
    local json_size=$(wc -c < "$json_out" 2>/dev/null || echo "0")
    local text_size=$(wc -c < "$text_out" 2>/dev/null || echo "0")
    echo "[DEBUG] JSON output size: $json_size bytes, Text output size: $text_size bytes" >&2
    
    if [ "$text_size" -eq 0 ]; then
        echo "[ERROR] LLM returned empty response" >&2
        echo "[DEBUG] Raw output saved to: $output_log" >&2
        echo "[DEBUG] First 500 chars of raw output: $(head -c 500 "$output_log" 2>/dev/null || echo 'no output')" >&2
        if [ -f "$error_log" ] && [ -s "$error_log" ]; then
            echo "[ERROR] LLM stderr: $(cat "$error_log")" >&2
        else
            echo "[ERROR] No error output from LLM (stderr was empty)" >&2
        fi
        echo "[INFO] To manually test, run: cat $prompt_file | llm" >&2
        rm -f "$error_log"
        return 1
    fi
    
    # Clean up error log on success
    rm -f "$error_log"
}

# (b) run first Claude pass and capture raw JSON + extracted text (original function kept as fallback)
build_prompt_with_claude() {
    local meta_prompt="$1"
    local json_out="$2"
    local text_out="$3"

    log_info "Building prompt with Claude (input: ${#meta_prompt} chars)..."
    
    # Check if prompt is very large (Claude can handle 100k+ tokens, roughly 400k+ chars)
    if [ ${#meta_prompt} -gt 200000 ]; then
        log_warning "Prompt is very large (${#meta_prompt} chars), may approach token limits"
    fi
    
    if [ ${#meta_prompt} -gt 400000 ]; then
        log_error "Prompt is extremely large (${#meta_prompt} chars), likely exceeds token limits"
        return 1
    fi
    
    # Save prompt for debugging
    local prompt_file="/tmp/claude-prompt-${RANDOM}.txt"
    printf '%s\n' "$meta_prompt" > "$prompt_file"
    log_info "Prompt saved to: $prompt_file for debugging"
    
    # Create error log file
    local error_log="/tmp/claude-error-${RANDOM}.log"
    local output_log="/tmp/claude-output-${RANDOM}.log"
    
    # Test if claude command exists and is executable
    if ! command -v claude &> /dev/null; then
        log_error "Claude command not found in PATH"
        return 1
    fi
    
    # Show the exact command being run
    log_info "Executing: claude -p --model sonnet --dangerously-skip-permissions --output-format json"
    
    # Use timeout command to prevent hanging on large prompts
    # Save prompt to file to avoid pipe buffering issues with large prompts
    local temp_input="/tmp/claude-input-${RANDOM}.txt"
    printf '%s\n' "$meta_prompt" > "$temp_input"
    
    # Run Claude with file input - no timeout, let it run as long as needed
    claude -p --model sonnet --dangerously-skip-permissions --output-format json < "$temp_input" 2>"$error_log" \
        | tee "$output_log" \
        | jq '.' >"$json_out" 2>/dev/null
    
    # Extract the result field from the JSON
    jq -r '
            # Debug: let user see what fields are available
            (if env.DEBUG then . else empty end),
            # 2025-06 CLI shape - try multiple possible locations
            if (.result? // "") != "" then .result
            elif (.response? // "") != "" then .response  
            elif (.content? // "") != "" then .content
            elif (.text? // "") != "" then .text
            # 2025-02 "message.content" shape
            elif (.choices[0].message.content? // "") != "" then .choices[0].message.content
            # 2025-04 "content" rename
            elif (.choices[0].content? // "") != "" then .choices[0].content
            # 2024 shape
            elif (.choices[0].text? // "") != "" then .choices[0].text
            # Last resort: try to find ANY non-empty string field
            elif (.choices[0]? // {} | to_entries[] | select(.value | type == "string" and length > 0) | .value) then (.choices[0]? // {} | to_entries[] | select(.value | type == "string" and length > 0) | .value | first)
            else empty end
        ' "$json_out" >"$text_out"
    
    # Clean up temp file
    rm -f "$temp_input"

    # Check for command failures
    local exit_code=$?
    if [ $exit_code -ne 0 ]; then
        echo "[ERROR] Claude command failed with exit code $exit_code" >&2
        if [ -f "$error_log" ]; then
            echo "[ERROR] Claude stderr: $(cat "$error_log")" >&2
        fi
        rm -f "$error_log"
        return 1
    fi

    # Debug: Check what we got from Claude
    if [ ! -f "$json_out" ]; then
        echo "[ERROR] No JSON output file created" >&2
        return 1
    fi
    
    local json_size=$(wc -c < "$json_out" 2>/dev/null || echo "0")
    echo "[DEBUG] JSON output size: $json_size bytes" >&2
    
    if [ "$json_size" -eq 0 ]; then
        echo "[ERROR] Claude returned empty response" >&2
        echo "[DEBUG] Raw output saved to: $output_log" >&2
        echo "[DEBUG] First 500 chars of raw output: $(head -c 500 "$output_log" 2>/dev/null || echo 'no output')" >&2
        if [ -f "$error_log" ] && [ -s "$error_log" ]; then
            echo "[ERROR] Claude stderr: $(cat "$error_log")" >&2
        else
            echo "[ERROR] No error output from Claude (stderr was empty)" >&2
        fi
        if [ "$CODER" = "codex" ]; then
            echo "[INFO] To manually test, run: cat $prompt_file | codex exec --model o3 --dangerously-bypass-approvals-and-sandbox" >&2
        else
            echo "[INFO] To manually test, run: cat $prompt_file | claude -p --model sonnet --dangerously-skip-permissions --output-format json" >&2
        fi
        rm -f "$error_log"
        return 1
    fi

    # Fail fast if no usable prompt was extracted
    if [[ ! -s $text_out ]]; then
        echo "[ERROR] Builder produced no usable prompt â€“ aborting. Available fields in JSON:" >&2
        echo "[ERROR] $(jq -r 'keys' "$json_out" 2>/dev/null || echo "Could not parse JSON")" >&2
        echo "[DEBUG] First 500 chars of JSON: $(head -c 500 "$json_out" 2>/dev/null)" >&2
        rm -f "$error_log"
        return 1 
    fi
    
    # Clean up error log on success
    rm -f "$error_log"
}

# (b) legacy helper - no longer used but kept for compatibility
extract_prompt_text() {
    local json_in="$1"             # /tmp/issue-N-prompt.json
    local prompt_out="$2"          # /tmp/issue-N-prompt.txt

    jq -r '
        # 2025-06 CLI shape
        if (.result? // "") != "" then .result
        # 2025-02 "message.content" shape
        elif (.choices[0].message.content? // "") != "" then .choices[0].message.content
        # 2025-04 "content" rename
        elif (.choices[0].content? // "") != "" then .choices[0].content
        # 2024 shape
        elif (.choices[0].text? // "") != "" then .choices[0].text
        else empty end
    ' "$json_in" >"$prompt_out"
}

# Detect the default branch (main or master)
detect_default_branch() {
    # Check if main exists
    if git show-ref --verify --quiet refs/heads/main; then
        echo "main"
    elif git show-ref --verify --quiet refs/heads/master; then
        echo "master"
    else
        # Try to detect from remote
        local remote_head=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
        if [ -n "$remote_head" ]; then
            echo "$remote_head"
        else
            # Default fallback
            echo "main"
        fi
    fi
}

# Create a new branch with timestamp (PURE - only outputs branch name)
create_branch() {
    local number="$1"
    local type="$2"  # "issue" or "pr"
    local branch_name

    # Use timestamped branch names to avoid conflicts on re-runs
    if [ "$type" = "issue" ]; then
        branch_name="issue-${number}-$(_ts)"
    else
        branch_name="review-pr-${number}-$(_ts)"
    fi

    # Create and checkout new branch (workspace already cleaned by workspace_hygiene)
    # Use -B to force creation/reset and checkout the base branch
    local base_branch="${BASE_BRANCH:-$(detect_default_branch)}"
    if git checkout -B "$branch_name" "$base_branch" >/dev/null 2>&1; then
        # PURE OUTPUT: only the branch name, no logging
        echo "$branch_name"
        return 0
    else
        return 1
    fi
}

# Execute coder (Claude or Codex) with proper parameters
execute_coder() {
    local final_prompt="$1"
    local output_file="$2"
    local interactive="$3"
    local coder="${4:-$CODER}"  # Use provided coder or default
    
    if [ "$coder" = "codex" ]; then
        execute_codex_with_retry "$final_prompt" "$output_file" "$interactive"
    else
        execute_claude_with_retry "$final_prompt" "$output_file" "$interactive"
    fi
}

# Execute Codex with retry logic
execute_codex_with_retry() {
    local final_prompt="$1"
    local output_file="$2"
    local interactive="$3"
    
    log_info "Executing Codex with retry logic..."
    
    # Use temporary file for consistent output handling
    local temp_output="/tmp/codex-raw-$$-$RANDOM.txt"
    
    for attempt in {1..5}; do
        log_info "Codex attempt ${attempt}/5..."
        
        local codex_cmd
        if [ "$interactive" = true ]; then
            # Interactive mode for codex (no -p flag like claude)
            codex_cmd="codex exec --model o3 --dangerously-bypass-approvals-and-sandbox"
        else
            # Codex exec is always non-interactive by default
            codex_cmd="codex exec --model o3 --dangerously-bypass-approvals-and-sandbox"
        fi
        
        # Execute and capture output
        local exit_code
        if [ "$interactive" = true ]; then
            # Show output on screen and capture to file
            echo "$final_prompt" | $codex_cmd | tee "$temp_output"
            exit_code=$?
        else
            # Headless mode - capture output directly to file
            echo "$final_prompt" | $codex_cmd > "$temp_output" 2>&1
            exit_code=$?
        fi
        
        if [ $exit_code -eq 0 ]; then
            # Strip ANSI escape codes and write to final output file
            sed -E 's/\x1B\[[0-9;]*[mK]//g' "$temp_output" > "$output_file"
            rm -f "$temp_output"
            log_success "Codex execution successful on attempt ${attempt}"
            return 0
        else
            log_warning "Codex execution failed (attempt ${attempt}/5, exit code: ${exit_code})"
            
            if [ $attempt -lt 5 ]; then
                log_info "Sleeping 90 seconds before retry due to potential rate limit..."
                sleep 90
            fi
        fi
    done
    
    rm -f "$temp_output"
    log_error "Failed to execute Codex after 5 attempts"
    return 1
}

# Execute Claude with retry logic for rate limiting
execute_claude_with_retry() {
    local final_prompt="$1"
    local output_file="$2"
    local interactive="$3"
    
    log_info "Executing Claude Code with retry logic..."
    
    for attempt in {1..5}; do
        log_info "Claude attempt ${attempt}/5..."
        
        local claude_cmd
        if [ "$interactive" = true ]; then
            claude_cmd="claude --model sonnet --dangerously-skip-permissions"
        else
            claude_cmd="claude -p --model sonnet --dangerously-skip-permissions"
        fi
        
        # Execute and capture output
        local exit_code
        local temp_output="/tmp/claude-raw-$$-$RANDOM.txt"
        
        if [ "$interactive" = true ]; then
            # Show output on screen and capture to file
            echo "$final_prompt" | $claude_cmd | tee "$temp_output"
            exit_code=$?
        else
            # Headless mode - capture output directly to file
            echo "$final_prompt" | $claude_cmd > "$temp_output" 2>&1
            exit_code=$?
        fi
        
        if [ $exit_code -eq 0 ]; then
            # Strip ANSI escape codes and write to final output file
            sed -E 's/\x1B\[[0-9;]*[mK]//g' "$temp_output" > "$output_file"
            rm -f "$temp_output"
            log_success "Claude execution successful on attempt ${attempt}"
            return 0
        else
            log_warning "Claude execution failed (attempt ${attempt}/5, exit code: ${exit_code})"
            rm -f "$temp_output"
            
            if [ $attempt -lt 5 ]; then
                log_info "Sleeping 90 seconds before retry due to potential rate limit..."
                sleep 90
            fi
        fi
    done
    
    log_error "Claude execution failed after 5 attempts"
    return 1
}

# Parse range syntax (e.g., "230-250" or "230")
parse_range() {
    local input="$1"
    
    if [[ $input =~ ^([0-9]+)-([0-9]+)$ ]]; then
        # Range format: start-end
        local start="${BASH_REMATCH[1]}"
        local end="${BASH_REMATCH[2]}"
        
        if [ "$start" -gt "$end" ]; then
            log_error "Invalid range: start ($start) cannot be greater than end ($end)"
            exit 1
        fi
        
        # Return array of numbers
        seq "$start" "$end"
    elif [[ $input =~ ^[0-9]+$ ]]; then
        # Single number
        echo "$input"
    else
        log_error "Invalid range format: $input (expected: number or start-end)"
        exit 1
    fi
}

# Fetch project information if project ID is provided
get_project_info() {
    local project_id="$1"
    
    if [ -z "$project_id" ]; then
        echo ""
        return
    fi

    log_info "Fetching project #${project_id} details..."
    
    local project_info
    project_info=$(gh project view "$project_id" --owner "$REPO_OWNER" --format json 2>/dev/null || {
        log_warning "Could not fetch project #${project_id}. Proceeding without project context."
        echo ""
        return
    })

    if [ -n "$project_info" ]; then
        log_success "Project information loaded"
        echo "$project_info"
    else
        echo ""
    fi
}

# Read and prepare CLAUDE.md content
get_claude_context() {
    if [ ! -f "CLAUDE.md" ]; then
        log_error "CLAUDE.md not found"
        exit 1
    fi

    log_info "Loading project context from CLAUDE.md..."
    cat "CLAUDE.md"
}

# Show usage information
show_usage() {
    echo "Usage:"
    echo "  $0 <github_issue_number> [options]                                   - Implement a single task"
    echo "  $0 <start_issue>-<end_issue> [options]                              - Implement a range of tasks"
    echo "  $0 --review-pr <pr_number> [options]                                - Review a single PR"
    echo "  $0 --review-pr <start_pr>-<end_pr> [options]                        - Review a range of PRs"
    echo "  $0 --bug \"<description>\" [options]                                  - Analyze bug and create GitHub issue"
    echo ""
    echo "Options:"
    echo "  --project <id>      Include GitHub project context (optional)"
    echo "  --prompt-only       Generate and display the prompt without executing Claude Code"
    echo "  --timeout <seconds> Sleep between tasks in range mode (default: 30 seconds)"
    echo "  --interactive       Use interactive Claude Code mode instead of headless (-p) mode"
    echo "  --auto-pr-review    Automatically review the PR after implementing an issue"
    echo "  --coder <claude|codex> Select AI coder to use (default: claude)"
    echo "  --base-branch <branch> Specify base branch for new branches (default: auto-detect main/master)"
    echo ""
    echo "Examples:"
    echo "  $0 316                                    # Audit and implement single issue (headless)"
    echo "  $0 230-250                               # Audit and implement range of issues (headless)"
    echo "  $0 230-250 --timeout 60                 # Range with 60s timeout between tasks"
    echo "  $0 316 --project 3                      # With project context"
    echo "  $0 316 --prompt-only                    # Generate Lyra-Dev prompt only"
    echo "  $0 316 --interactive                    # Single issue with interactive mode"
    echo "  $0 316 --auto-pr-review                 # Implement issue and auto-review the created PR"
    echo "  $0 403-405 --auto-pr-review             # Implement range and auto-review all created PRs"
    echo "  $0 --review-pr 329                      # Review single PR (read-only analysis)"
    echo "  $0 --review-pr 325-330                  # Review range of PRs (read-only analysis)"
    echo "  $0 --review-pr 325-330 --timeout 45     # Range with 45s timeout"
    echo "  $0 --review-pr 329 --interactive        # Interactive PR review (posts comment)"
    echo "  $0 --bug \"Login fails with 500 error\"  # Analyze bug and create GitHub issue"
    echo "  $0 --bug \"App crashes on startup\" --prompt-only  # Generate bug analysis prompt only"
    echo "  $0 --bug \"Payment processing timeout\" --interactive  # Interactive bug analysis"
    echo "  $0 316 --coder codex                       # Use Codex instead of Claude"
    echo "  $0 316 --coder codex --interactive         # Use Codex interactively"
    echo "  $0 316 --base-branch develop               # Create branch from 'develop' instead of main/master"
    echo ""
    echo "Requirements:"
    echo "  - Must be run from a directory containing CLAUDE.md"
    echo "  - Must be in a git repository with GitHub remote"
    echo "  - Requires: gh (GitHub CLI), git, claude (Claude Code), jq (JSON processor)"
    echo ""
    echo "Range Mode Features:"
    echo "  - TWO-STAGE EXECUTION for ISSUES: prompt-builder Claude â†’ executor Claude (eliminates meta-prompts)"
    echo "  - SINGLE-STAGE EXECUTION for PR REVIEWS: direct review prompt â†’ gh pr comment"
    echo "  - IMPLEMENTATION MODE: Claude audits and fixes gaps in one run (creates branches/PRs)"
    echo "  - REVIEW MODE: Direct PR analysis with actionable feedback via GitHub CLI comments"
    echo "  - BUG REPORT MODE: Analyzes codebase to identify likely causes and creates detailed GitHub issues"
    echo "  - Issue comments: posts audit results for transparency (implementation mode only)"
    echo "  - Smart PR creation: only when actual code changes are made (implementation mode only)"
    echo "  - Creates timestamped branches for each task (implementation mode only)"
    echo "  - Auto-closes issues when audit shows they're already complete"
    echo "  - Gracefully handles mixed scenarios (some complete, some need work)"
    echo "  - Automatically sleeps between tasks to prevent API rate limiting"
    echo "  - Continues processing even if individual tasks fail"
    echo "  - Use --interactive for manual control of each Claude Code session"
    echo "  - Default headless mode (-p) processes tasks automatically"
    echo "  - Uses Lyra-Dev framework for optimized prompt generation (implementation mode)"
    echo "  - CRITICAL: Status verification prevents duplicate work on 'completed' tasks"
    echo "  - Robust retry logic with exponential backoff for API rate limits"
}

# Parse command line arguments
parse_arguments() {
    MODE=""
    ISSUE_RANGE=""
    PR_RANGE=""
    BUG_DESCRIPTION=""
    PROJECT_ID=""
    PROMPT_ONLY=false
    INTERACTIVE=false
    AUTO_PR_REVIEW=false
    TIMEOUT_SECONDS=30  # Default timeout
    CODER="claude"  # Default coder (claude or codex)
    BASE_BRANCH=""  # Base branch for creating new branches

    while [[ $# -gt 0 ]]; do
        case $1 in
            --review-pr)
                if [ -n "$MODE" ]; then
                    log_error "Cannot specify both --review-pr and issue number/range"
                    exit 1
                fi
                MODE="review"
                shift
                if [[ $# -gt 0 && ($1 =~ ^[0-9]+$ || $1 =~ ^[0-9]+-[0-9]+$) ]]; then
                    PR_RANGE="$1"
                    shift
                else
                    log_error "--review-pr requires a PR number or range (e.g., 325 or 325-330)"
                    exit 1
                fi
                ;;
            --bug)
                if [ -n "$MODE" ]; then
                    log_error "Cannot specify both --bug and other modes"
                    exit 1
                fi
                MODE="bug"
                shift
                if [[ $# -gt 0 && -n "$1" ]]; then
                    BUG_DESCRIPTION="$1"
                    shift
                else
                    log_error "--bug requires a description in quotes (e.g., --bug \"Login fails with 500 error\")"
                    exit 1
                fi
                ;;
            --project)
                shift
                if [[ $# -gt 0 && $1 =~ ^[0-9]+$ ]]; then
                    PROJECT_ID="$1"
                    shift
                else
                    log_error "--project requires a project ID"
                    exit 1
                fi
                ;;
            --prompt-only)
                PROMPT_ONLY=true
                shift
                ;;
            --interactive)
                INTERACTIVE=true
                shift
                ;;
            --auto-pr-review)
                AUTO_PR_REVIEW=true
                shift
                ;;
            --timeout)
                shift
                if [[ $# -gt 0 && $1 =~ ^[0-9]+$ ]]; then
                    TIMEOUT_SECONDS="$1"
                    shift
                else
                    log_error "--timeout requires a number of seconds"
                    exit 1
                fi
                ;;
            --coder)
                shift
                if [[ $# -gt 0 && ($1 == "claude" || $1 == "codex") ]]; then
                    CODER="$1"
                    shift
                else
                    log_error "--coder requires either 'claude' or 'codex'"
                    exit 1
                fi
                ;;
            --base-branch)
                shift
                if [[ $# -gt 0 && -n "$1" ]]; then
                    BASE_BRANCH="$1"
                    shift
                else
                    log_error "--base-branch requires a branch name"
                    exit 1
                fi
                ;;
            --help|-h)
                show_usage
                exit 0
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                # This should be an issue number or range for implementation mode
                if [[ $1 =~ ^[0-9]+$ || $1 =~ ^[0-9]+-[0-9]+$ ]]; then
                    if [ -n "$MODE" ]; then
                        log_error "Cannot specify both issue number/range and other modes"
                        exit 1
                    fi
                    MODE="implement"
                    ISSUE_RANGE="$1"
                    shift
                else
                    log_error "Invalid argument: $1 (expected: number, range, --review-pr, or --bug)"
                    show_usage
                    exit 1
                fi
                ;;
        esac
    done

    # Validate arguments
    if [ -z "$MODE" ]; then
        log_error "No command specified"
        show_usage
        exit 1
    fi

    if [ "$MODE" = "implement" ] && [ -z "$ISSUE_RANGE" ]; then
        log_error "Issue number or range required for implementation mode"
        exit 1
    fi

    if [ "$MODE" = "review" ] && [ -z "$PR_RANGE" ]; then
        log_error "PR number or range required for review mode"
        exit 1
    fi

    if [ "$MODE" = "bug" ] && [ -z "$BUG_DESCRIPTION" ]; then
        log_error "Bug description required for bug report mode"
        exit 1
    fi

    if [ -n "$PROJECT_ID" ] && ! [[ "$PROJECT_ID" =~ ^[0-9]+$ ]]; then
        log_error "Project ID must be a positive integer"
        exit 1
    fi

    if ! [[ "$TIMEOUT_SECONDS" =~ ^[0-9]+$ ]]; then
        log_error "Timeout must be a positive integer (seconds)"
        exit 1
    fi

    # Validate conflicting options
    if [ "$PROMPT_ONLY" = true ] && [ "$INTERACTIVE" = true ]; then
        log_error "Cannot use --prompt-only and --interactive together"
        exit 1
    fi
    
    if [ "$AUTO_PR_REVIEW" = true ] && [ "$MODE" != "implement" ]; then
        log_error "--auto-pr-review can only be used with issue implementation mode (not --review-pr or --bug)"
        exit 1
    fi
}

# Generate the base Lyra-Dev prompt framework
generate_base_lyra_prompt() {
    local repo_owner="$1"
    local repo_name="$2"
    local claude_context="$3"
    local project_info="$4"

    cat << 'EOF'
# Lyra-Dev: Claude-Compatible Prompt Optimizer for Software Tasks

You are **Lyra-Dev**, an elite AI prompt optimizer embedded in a dev workflow. Your role is to transform stitched-together context â€” from READMEs, codebase rules, and tasks (e.g. kanban cards, PRs) â€” into a **fully-formed, self-reliant prompt** tailored for Claude (Code model), ready for autonomous execution with no back-and-forth interaction.

You never ask questions. Instead, you **reason through missing details**, assume safe defaults, and state those assumptions in the output. Your prompts must always be actionable, context-aware, and structured.

**CRITICAL**: Generate COMPREHENSIVE yet CONCISE prompts that include all important details and are clear and actionable. Focus on essential information while avoiding excessive repetition or unnecessarily verbose instructions.

---

## ðŸ”„ THE 4-D METHODOLOGY (Headless Software Edition)

### 1. DECONSTRUCT
- Extract task intent, key entities (files, services, APIs), and project context.
- Identify output requirements: code, test, rationale, config, etc.
- Map what is provided vs. what is missing (README, rules, task description).

### 2. DIAGNOSE
- Check for ambiguity or unclear expectations.
- **CRITICAL: Verify claimed completion status** - Many tasks claim to be "done" when they're not.
- Identify missing constraints or implicit assumptions.
- **Gap Analysis**: Compare claimed vs actual implementation state.
- If any required information is absent, infer it from surrounding context or apply safe defaults.

### 3. DEVELOP
- Select the right approach based on task type:
  - **Bug Fixes** â†’ Constraint-based logic, minimal change, clarity
  - **New Features** â†’ Step-by-step reasoning, layered context
  - **Refactors** â†’ Chain-of-thought logic + pattern recognition
  - **PR Reviews** â†’ Multi-perspective analysis + rules enforcement
  - **Status Verification** â†’ Audit claimed vs actual, focus on gaps only
- Assign a role to Claude (e.g. "Act as a senior backend engineer").
- Embed project rules, output format requirements, and tone (if applicable).

### 4. DELIVER
- Output the optimized prompt that INSTRUCTS Claude to use the 4-D methodology.
- The prompt you create must tell Claude to structure its response as: DECONSTRUCT â†’ DIAGNOSE â†’ DEVELOP â†’ DELIVER
- Include explicit instructions for Claude to follow the 4-D workflow in its implementation.
- **CRITICAL**: Emphasize that Claude MUST follow ALL rules and guidelines from CLAUDE.md throughout the implementation.
- Embed context, clarify assumptions, and specify that Claude must use the 4-D format.
- The final prompt should make Claude act as a senior engineer using the 4-D methodology while strictly adhering to CLAUDE.md guidelines.

---

## âš™ï¸ OPTIMIZATION TECHNIQUES

**Foundation:**  
- Role assignment  
- Context layering  
- Output specification  
- Task decomposition  

**Advanced:**  
- Chain-of-thought reasoning  
- Constraint optimization  
- Multi-perspective evaluation  
- Few-shot learning (if examples are available)  

---

## ðŸ“ OUTPUT PROMPT REQUIREMENTS

Your generated prompt for Claude MUST include these elements:

**1. Role Assignment:**
```
You are a senior software engineer implementing [specific task].
```

**2. 4-D Methodology Instruction (MANDATORY):**
```
You MUST structure your entire response using the 4-D methodology with these EXACT section headers:

# DECONSTRUCT
[Analyze the task requirements and current codebase state]

# DIAGNOSE  
[Identify gaps between requirements and current implementation]

# DEVELOP
[Plan your implementation approach following CLAUDE.md guidelines]

# DELIVER
[Implement the code, tests, and documentation according to CLAUDE.md rules]

IMPORTANT: Use these exact headers (DECONSTRUCT, DIAGNOSE, DEVELOP, DELIVER) - NOT "Design, Deploy, Document" or other variations.
```

**3. CLAUDE.md Compliance (CRITICAL):**
```
IMPORTANT: You MUST follow ALL guidelines and rules specified in CLAUDE.md. Key areas to pay attention to:
- Project-specific coding conventions and patterns
- Required tools and workflows (e.g., Conda environments, testing frameworks)
- Infrastructure patterns (e.g., Tofu/Terraform for GCP resources)
- File organization and naming conventions
- Any deprecated patterns or legacy components to avoid
- Security and authentication requirements

Before writing any code, review the CLAUDE.md guidelines and ensure your implementation adheres to ALL specified rules.
```

**4. Context Integration:**
- Explicitly reference specific CLAUDE.md sections relevant to the task
- Include the specific issue/task details
- Mention any constraints or requirements from CLAUDE.md

**5. Clear Expectations:**
- Specify that Claude should make actual code changes
- Request tests and documentation
- Emphasize following project conventions from CLAUDE.md

**6. GitHub Transparency Requirements:**
```
IMPORTANT: After completing your implementation, you MUST post a comment on the GitHub issue/PR explaining:
- What gaps were identified during your audit
- What specific changes you made to fill those gaps
- What testing was performed
- Any assumptions or decisions made during implementation

Use `gh issue comment <issue_number> --body "..."` or `gh pr comment <pr_number> --body "..."` to post your summary.
```

---

## ðŸ¤– TARGET PLATFORM: CLAUDE (Code)

- Long-form reasoning supported  
- Handles layered context well  
- Responds best to clearly scoped, structured tasks  
- Avoid ambiguous phrasing or unstated expectations  

---

## ðŸ” EXECUTION LOGIC (Automated Flow)

1. Auto-detect task complexity from input.
2. Apply DETAIL mode logic (self-contained reasoning).
3. Never ask the user questions. Instead, note assumptions and proceed.
4. Deliver prompt using the structure below.

---
EOF

    echo ""
    echo "## ðŸ“‹ PROJECT CONTEXT"
    echo ""
    echo "**Repository:** ${repo_owner}/${repo_name}"
    echo ""
    echo "### Project Guidelines (CLAUDE.md)"
    echo '```'
    echo "$claude_context"
    echo '```'
    echo ""
    
    if [ -n "$project_info" ]; then
        echo "### GitHub Project Context"
        echo '```json'
        echo "$project_info"
        echo '```'
        echo ""
    fi
    
    echo ""
    echo "---"
    echo ""
    echo "You are an agent - please keep going until the user's query is completely resolved, before ending"
    echo "your turn and yielding back to the user. Only terminate your turn when you are sure that the problem"
    echo "is solved."
    echo ""
    echo "If you are not sure about file content or codebase structure pertaining to the user's request, use"
    echo "your tools to read files and gather the relevant information: do NOT guess or make up an answer."
    echo ""
    echo "You MUST plan extensively before each function call, and reflect extensively on the outcomes of the"
    echo "previous function calls. DO NOT do this entire process by making function calls only, as this can"
    echo "impair your ability to solve the problem and think insightfully."
}

# Generate implementation-specific addendum
generate_implementation_addendum() {
    local issue_number="$1"
    local issue_details="$2"

    cat << EOF

---

## ðŸ› ï¸ IMPLEMENTATION MODE: ISSUE #${issue_number}

### TASK CONTEXT
${issue_details}

### IMPLEMENTATION REQUIREMENTS

**Role Assignment:** Act as a **senior software engineer** implementing this feature/fix.

**CRITICAL - Status Verification Protocol:**
Before any implementation work, you MUST audit the current state:

1. **Check for PR Feedback**: If PR feedback is provided below, prioritize addressing those specific concerns
2. **Verify Claims vs Reality**: The issue claims certain completion levels - these may be inaccurate
3. **Investigate Actual Implementation**: Check the codebase for actual feature implementation  
4. **Gap Analysis**: Identify what's actually missing vs what's claimed to be done
5. **Focus on Gaps**: Only implement what's actually missing, don't duplicate existing work
6. **Address Review Comments**: If this is updating an existing PR, ensure all review feedback is addressed

**Context Priority:**
1. Follow all guidelines specified in CLAUDE.md
2. Maintain existing project patterns and conventions
3. Use terraform for GCP resource management (if applicable)
4. Write comprehensive tests following project testing patterns
5. Ensure backwards compatibility unless explicitly breaking change

**Output Format Required:**
\`\`\`
# DECONSTRUCT
[Analysis of what the issue claims vs what actually needs to be built]

# DIAGNOSE  
[Status verification: What's claimed vs actual implementation state]
[PR Feedback Review: If PR feedback exists, list specific concerns to address]
[Assumptions made about implementation approach, missing details]

# DEVELOP
[Step-by-step plan prioritizing PR feedback (if any), then focusing on gaps/missing pieces]

# DELIVER
[Implementation of missing pieces only, tests, and documentation]

# STATUS AUDIT
- **Claimed Status**: [What the issue claims to be done]
- **Actual Status**: [What you found in the codebase]
- **Work Required**: [Specific gaps that need to be filled]
- **Approach**: [Complete missing pieces vs full reimplementation]

# COMPLETION CHECKLIST
- [ ] PR feedback addressed (if any) - all review comments resolved
- [ ] Status verification completed - identified actual vs claimed implementation
- [ ] Gap analysis performed - focused only on missing pieces
- [ ] Code implements the missing functionality (not duplicating existing work)
- [ ] Tests written for new/missing functionality
- [ ] Documentation updated for changes made
- [ ] Code follows project conventions from CLAUDE.md
- [ ] Ready for PR creation/update
- [ ] GitHub issue comment posted with implementation summary

# MANDATORY: POST IMPLEMENTATION SUMMARY
After completing your work, you MUST post a comment on issue #${issue_number} using:
\`\`\`bash
gh issue comment ${issue_number} --body "ðŸ¤– **Implementation Summary**

**Status Audit:**
- Claimed Status: [what issue claimed]
- Actual Status: [what you found] 
- Work Completed: [specific gaps filled]

**Changes Made:**
- [list specific files/functionality implemented]
- [testing performed]
- [any assumptions/decisions made]

**Result:** [Ready for review / Needs additional work / etc.]"
\`\`\`

# FINAL STEP: CREATE/UPDATE PULL REQUEST
Create or update the PR with:
- Clear description of what gaps were filled or feedback addressed
- Link to issue #${issue_number}
- Status audit summary (claimed vs actual vs completed)
- Review feedback resolution notes (if updating existing PR)
- Testing notes for new functionality only
- Any breaking changes or migration notes
\`\`\`

**Critical Instructions:**
1. **PRIORITIZE PR FEEDBACK** - if review feedback exists, address those concerns first and foremost
2. **NEVER take issue status claims at face value** - always verify by examining the codebase
3. **Focus on gaps, not greenfield implementation** - most "incomplete" features are partially done
4. **Document status discrepancies** - note when claimed status doesn't match reality
5. **Be surgical in your changes** - only implement what's actually missing or address specific feedback
6. **AUDIT AND IMPLEMENT IN ONE RUN** - conduct the mandatory status verification and, in the same run, implement every gap you identify. The working tree must end in a fully gap-filled state, complete with tests and docs.

Begin conducting status verification and implementing all identified gaps for issue #${issue_number} using the 4-D methodology.
EOF
}

# Generate PR review-specific prompt (SIMPLIFIED - direct execution, no meta-prompt)
generate_review_prompt() {
    local pr_number="$1"
    local pr_details="$2"
    local pr_diff="$3"
    local claude_context="$4"
    local repo_owner="$5"
    local repo_name="$6"

    cat << EOF
# Senior Code Review - PR #${pr_number}

You are a **senior software engineer** conducting a thorough code review of PR #${pr_number} in ${repo_owner}/${repo_name}.

## ðŸ”„ 4-D REVIEW METHODOLOGY

### 1. DECONSTRUCT
- Analyze what this PR accomplishes and its scope
- Identify the key changes, files modified, and functionality affected
- Map the changes to the project's architecture and conventions

### 2. DIAGNOSE  
- Identify potential issues, risks, or concerns in the changes
- Check for security vulnerabilities, performance impacts, and maintainability issues
- Assess adherence to project guidelines and coding standards

### 3. DEVELOP
- Provide specific, actionable feedback with file names and line numbers
- Suggest concrete improvements and alternatives
- Reference project patterns and conventions that should be followed

### 4. DELIVER
- Make final review decision: APPROVE, REQUEST_CHANGES, or COMMENT
- Use GitHub CLI to post your review with clear reasoning

---

## ðŸ“‹ PROJECT CONTEXT

**Repository:** ${repo_owner}/${repo_name}

### Project Guidelines (CLAUDE.md)
\`\`\`
${claude_context}
\`\`\`

---

## ðŸ” PR DETAILS

${pr_details}

---

## ðŸ“ CODE CHANGES

\`\`\`diff
${pr_diff}
\`\`\`

---

## ðŸ“‹ REVIEW REQUIREMENTS

Conduct a thorough technical review focusing on:

1. **Code Quality**: Does it follow project conventions from CLAUDE.md?
2. **Security**: Any potential vulnerabilities or security risks?
3. **Performance**: Will this impact system performance negatively?
4. **Architecture**: Is it consistent with existing patterns and design?
5. **Testing**: Are there adequate tests for the changes?
6. **Documentation**: Is documentation updated appropriately?

## ðŸŽ¯ OUTPUT FORMAT

Provide your review in this exact format:

\`\`\`
# DECONSTRUCT
[What this PR does and its scope - 2-3 sentences]

# DIAGNOSE
[Issues found, concerns, or areas that need attention]

# DEVELOP
[Specific feedback with actionable suggestions]

# DELIVER

## Code Review Summary
[Brief explanation of your overall assessment]

## Issues Found
- **[filename:line]**: [specific issue and how to fix it]
- **[filename:function]**: [pattern/convention issue and correct approach]
- **[general]**: [broader concerns and recommendations]

## Recommendations
- [Actionable steps the author should take]
- [Best practices to follow based on CLAUDE.md]

## Positive Aspects
- [Things done well in this PR, if any]

\`\`\`

## ðŸš€ FINAL INSTRUCTION

After completing your analysis above, you MUST use the GitHub CLI to post a comment on the PR:

**Always use:**
\`gh pr comment ${pr_number} --body "YOUR_DETAILED_REVIEW_HERE"\`

**Format your comment with clear sections:**
- **Summary**: Brief overview of your assessment
- **Issues Found**: Specific problems with file:line references
- **Recommendations**: Actionable next steps for the author
- **Positive Notes**: What was done well (if applicable)

**Be specific and actionable** - engineers need to know exactly what to fix and how to fix it. Include file names, function names, line numbers, and specific code examples when possible.

Begin your review now.

---

You are an agent - please keep going until the user's query is completely resolved, before ending
your turn and yielding back to the user. Only terminate your turn when you are sure that the problem
is solved.

If you are not sure about file content or codebase structure pertaining to the user's request, use
your tools to read files and gather the relevant information: do NOT guess or make up an answer.

You MUST plan extensively before each function call, and reflect extensively on the outcomes of the
previous function calls. DO NOT do this entire process by making function calls only, as this can
impair your ability to solve the problem and think insightfully.
EOF
}

# Generate bug analysis prompt for creating detailed bug reports
generate_bug_analysis_prompt() {
    local bug_description="$1"
    local claude_context="$2"
    local repo_owner="$3"
    local repo_name="$4"

    cat << EOF
# Bug Analysis and GitHub Issue Creation

You are a senior software engineer analyzing a bug report to create a comprehensive GitHub issue. Your role is to:
1. Analyze the provided bug description
2. Search the codebase for likely causes and related code
3. Generate a detailed, structured bug report for GitHub

## Project Context
Repository: ${repo_owner}/${repo_name}

${claude_context}

## Reported Bug Description
"${bug_description}"

## Your Analysis Tasks

### 1. INVESTIGATE THE CODEBASE
- Search for relevant files, functions, and code patterns related to the bug description
- Identify potential areas where this bug could be occurring
- Look for error handling, validation, API endpoints, UI components, etc. that match the description
- Examine recent commits, configuration files, and dependencies if relevant

### 2. ANALYZE POTENTIAL CAUSES
- Based on your codebase investigation, identify likely causes
- Consider common bug patterns: validation issues, race conditions, configuration problems, API failures, etc.
- Look for similar existing issues or TODO comments in the code
- Identify the severity and priority of the bug

### 3. CREATE COMPREHENSIVE BUG REPORT
Format your analysis into a structured GitHub issue using this template:

\`\`\`
# Bug Report: [Descriptive Title Based on Analysis]

## ðŸ› Description
[Clear description of the bug based on the original report and your analysis]

## ðŸ” Analysis Results
**Likely Location**: [Files/functions where bug probably occurs based on codebase analysis]
**Potential Causes**: [Technical analysis of what might be causing this]
**Severity**: [Critical/Major/Minor based on analysis]
**Priority**: [High/Medium/Low based on impact assessment]

## ðŸ“‹ Steps to Reproduce
[If you can infer steps from the description and codebase analysis, provide them. Otherwise note "To be determined"]

## ðŸŽ¯ Expected Behavior
[What should happen instead]

## ðŸ“± Environment Details
[If mentioned in description or inferable from codebase, include relevant environment info]

## ðŸ”§ Technical Investigation
**Relevant Code Areas**:
- \`path/to/file.ext:line_number\` - [Brief description of relevance]
- \`another/file.ext:function_name\` - [Why this might be related]

**Potential Root Causes**:
1. [Most likely cause based on code analysis]
2. [Second most likely cause]
3. [Other possibilities]

## ðŸ§ª Suggested Investigation Steps
1. [Specific debugging steps for developers]
2. [Areas to check first]
3. [Tools or methods to verify the issue]

## ðŸ’¡ Possible Solutions
[If you can identify potential fixes based on the codebase]

## ðŸ“Ž Additional Context
[Any other relevant information from your codebase analysis]

## ðŸ·ï¸ Labels
[Suggest appropriate labels: bug, priority-high/medium/low, area-frontend/backend/api, etc.]
\`\`\`

## ðŸš€ FINAL INSTRUCTION

After completing your analysis, create the GitHub issue using:
\`gh issue create --title "Bug: [Your descriptive title]" --body "YOUR_DETAILED_BUG_REPORT_HERE" --label "bug"\`

Additional labels to consider based on your analysis:
- \`priority-high\`, \`priority-medium\`, \`priority-low\`
- \`severity-critical\`, \`severity-major\`, \`severity-minor\`
- \`area-frontend\`, \`area-backend\`, \`area-api\`, \`area-ui\`, etc.
- \`investigation-needed\` if more details are required

**Important**: 
- Be thorough but factual - only include what you can reasonably infer from the description and codebase
- If information is missing, clearly state "To be determined" rather than guessing
- Focus on actionable technical details that will help developers investigate and fix the issue
- Include specific file paths and line numbers when you find relevant code

Begin your analysis now.

---

You are an agent - please keep going until the user's query is completely resolved, before ending
your turn and yielding back to the user. Only terminate your turn when you are sure that the problem
is solved.

If you are not sure about file content or codebase structure pertaining to the user's request, use
your tools to read files and gather the relevant information: do NOT guess or make up an answer.

You MUST plan extensively before each function call, and reflect extensively on the outcomes of the
previous function calls. DO NOT do this entire process by making function calls only, as this can
impair your ability to solve the problem and think insightfully.
EOF
}

# Generate direct implementation prompt for addressing PR feedback (no meta-prompt)
generate_pr_feedback_implementation_prompt() {
    local issue_number="$1"
    local issue_details="$2"
    local pr_feedback="$3"
    local claude_context="$4"
    local repo_owner="$5"
    local repo_name="$6"

    cat << EOF
# Address PR Feedback - Issue #${issue_number}

You are a senior software engineer addressing specific PR review feedback. Your task is to make the necessary code changes to address all review comments and push the updates to the current branch.

## Repository Context
Repository: ${repo_owner}/${repo_name}

${claude_context}

## Original Issue Context
${issue_details}

${pr_feedback}

## Your Task

You must address ALL the feedback above by making the necessary code changes. This is not about analysis or planning - you need to:

1. **Review each piece of feedback** and understand what changes are requested
2. **Make the specific code changes** to address each concern
3. **Ensure code quality** - fix any bugs, improve implementation, add tests if needed
4. **Follow project conventions** as specified in CLAUDE.md
5. **Commit and push changes** to the current branch

## Critical Requirements

- Address EVERY piece of feedback provided above
- Make actual code changes, don't just acknowledge the feedback
- Test your changes to ensure they work
- Follow the existing code patterns and conventions
- Write clear commit messages describing what feedback was addressed
- Push changes to the current branch so PR can be re-reviewed

## Expected Workflow

1. Read through all the PR feedback carefully
2. Identify the specific files and changes needed
3. Make the necessary code modifications
4. Test your changes (run relevant tests if they exist)
5. Commit with descriptive messages
6. Push to the current branch

Begin addressing the PR feedback now. Make the actual code changes required.

---

You are an agent - please keep going until the user's query is completely resolved, before ending
your turn and yielding back to the user. Only terminate your turn when you are sure that the problem
is solved.

If you are not sure about file content or codebase structure pertaining to the user's request, use
your tools to read files and gather the relevant information: do NOT guess or make up an answer.

You MUST plan extensively before each function call, and reflect extensively on the outcomes of the
previous function calls. DO NOT do this entire process by making function calls only, as this can
impair your ability to solve the problem and think insightfully.
EOF
}

# Fetch PR review comments and feedback for addressing in subsequent implementations
get_pr_feedback() {
    local pr_number="$1"
    
    if [ -z "$pr_number" ]; then
        echo ""
        return
    fi
    
    log_info "Fetching PR #${pr_number} review feedback..." >&2
    
    # Fetch PR reviews and comments
    local pr_reviews
    pr_reviews=$(gh pr view "$pr_number" --repo "${REPO_OWNER}/${REPO_NAME}" --json reviews,comments --jq '.reviews[] | select(.state == "CHANGES_REQUESTED" or .state == "COMMENTED") | {author: .author.login, state: .state, body: .body, submittedAt: .submittedAt}' 2>/dev/null || echo "")
    
    local pr_comments
    pr_comments=$(gh pr view "$pr_number" --repo "${REPO_OWNER}/${REPO_NAME}" --json comments --jq '.comments[] | {author: .author.login, body: .body, createdAt: .createdAt}' 2>/dev/null || echo "")
    
    # Get review comments (line-specific comments)
    local review_comments
    review_comments=$(gh api "repos/${REPO_OWNER}/${REPO_NAME}/pulls/${pr_number}/comments" --jq '.[] | {author: .user.login, body: .body, path: .path, line: .line, createdAt: .created_at}' 2>/dev/null || echo "")
    
    # Debug logging
    log_info "PR reviews found: ${#pr_reviews} chars" >&2
    log_info "PR comments found: ${#pr_comments} chars" >&2
    log_info "Review comments found: ${#review_comments} chars" >&2
    
    # Combine all feedback if any exists
    if [ -n "$pr_reviews" ] || [ -n "$pr_comments" ] || [ -n "$review_comments" ]; then
        log_success "Found PR review feedback to address" >&2
        
        cat << EOF

## ðŸ”„ EXISTING PR FEEDBACK TO ADDRESS

**PR #${pr_number} Review Feedback:**

### General Reviews:
${pr_reviews}

### Discussion Comments:
${pr_comments}

### Code Review Comments:
${review_comments}

**CRITICAL**: The above feedback must be addressed in your implementation. This is not a greenfield implementation - you are updating an existing PR to address specific review concerns.

EOF
    else
        log_info "No review feedback found for PR #${pr_number}" >&2
        echo ""
    fi
}

# Smart branch management: reuse existing PR branches or create new ones
smart_branch_setup() {
    local number="$1"
    local task_type="$2"
    
    log_info "=== SMART BRANCH SETUP FOR ${task_type} #${number} ==="
    
    # Check for existing open PRs for this issue
    log_info "Checking for existing open PRs for issue #${number}..."
    local existing_prs
    existing_prs=$(gh pr list --repo "${REPO_OWNER}/${REPO_NAME}" --search "closes:#${number} OR fixes:#${number} OR issue #${number}" --state open --json number,title,headRefName 2>/dev/null || echo "[]")
    
    if [ "$existing_prs" != "[]" ] && [ -n "$existing_prs" ]; then
        # Found existing PR(s) - use the first one
        local existing_branch
        existing_branch=$(echo "$existing_prs" | jq -r '.[0].headRefName' 2>/dev/null)
        local existing_pr_number
        existing_pr_number=$(echo "$existing_prs" | jq -r '.[0].number' 2>/dev/null)
        
        if [ -n "$existing_branch" ] && [ "$existing_branch" != "null" ]; then
            log_success "FOUND EXISTING OPEN PR #${existing_pr_number} with branch: ${existing_branch}"
            log_info "REUSING existing branch instead of creating new one..."
            
            # Fetch the branch from remote
            log_info "Fetching existing branch from remote..."
            git fetch origin "$existing_branch" || {
                log_warning "Could not fetch branch ${existing_branch}, will create new one"
                return 1
            }
            
            # Checkout the existing branch
            if git checkout "$existing_branch" >/dev/null 2>&1; then
                log_success "Switched to existing branch: ${existing_branch}" >&2
                
                # Pull latest changes
                log_info "Pulling latest changes from origin/${existing_branch}..." >&2
                git pull origin "$existing_branch" >/dev/null 2>&1 || {
                    log_warning "Could not pull latest changes, continuing anyway" >&2
                }
                
                echo "${existing_branch}|${existing_pr_number}"  # Return branch name and PR number
                return 0
            else
                log_warning "Could not checkout existing branch ${existing_branch}, will create new one"
                return 1
            fi
        else
            log_warning "Could not extract branch name from existing PR, will create new one"
            return 1
        fi
    else
        log_info "No existing open PRs found for issue #${number}"
        return 1  # Signal to create new branch
    fi
}

# Review a PR using Claude
review_pr() {
    local pr_number="$1"
    local claude_context="$2"
    local repo_owner="$3"
    local repo_name="$4"
    
    log_info "ðŸ” Starting automated review of PR #${pr_number}..."
    
    # Fetch PR details
    log_info "Fetching PR #${pr_number} details..."
    local pr_details
    pr_details=$(gh pr view "$pr_number" --repo "${repo_owner}/${repo_name}" --json title,body,headRefName,baseRefName,author,additions,deletions,changedFiles,commits,reviewDecision,mergeable,url 2>/dev/null || {
        log_error "Could not fetch PR #${pr_number}. Please check the PR number and your GitHub access."
        return 1
    })

    # Fetch PR diff
    log_info "Fetching PR diff..."
    local pr_diff
    pr_diff=$(gh pr diff "$pr_number" --repo "${repo_owner}/${repo_name}" 2>/dev/null || {
        log_error "Could not fetch PR diff for #${pr_number}"
        return 1
    })
    
    # Generate review prompt
    log_info "Generating direct review prompt (single-stage)..."
    local final_prompt
    final_prompt=$(generate_review_prompt "$pr_number" "$pr_details" "$pr_diff" "$claude_context" "$repo_owner" "$repo_name")
    
    if [ -z "$final_prompt" ]; then
        log_error "Failed to generate review prompt for PR #${pr_number}"
        return 1
    fi
    
    # Execute Claude for PR review
    local output_file="/tmp/pr-${pr_number}-review-output.md"
    
    if [ "$INTERACTIVE" = true ]; then
        log_info "Direct Claude execution in INTERACTIVE mode for PR review #${pr_number}..."
    else
        log_info "Direct Claude execution in HEADLESS mode for PR review #${pr_number}..."
    fi
    
    # Log PR review prompt size before sending to Claude
    log_info "Sending PR review prompt to Claude (${#final_prompt} bytes)"
    
    local run_mode=$([[ $INTERACTIVE == true ]] && echo "interactive" || echo "headless")
    if ! run_claude "$final_prompt" "$output_file" "$run_mode"; then
        log_error "Claude execution failed for PR review #${pr_number}"
        return 1
    fi
    
    log_success "Claude execution completed for PR review #${pr_number}"
    
    # Log final output file details before processing
    if [ -f "$output_file" ]; then
        local final_output_size=$(wc -c < "$output_file" 2>/dev/null || echo "0")
        log_info "Final Claude review output file: $output_file (${final_output_size} bytes)"
        if [ "$final_output_size" -eq 0 ]; then
            log_warning "Claude review output file is empty - review may have failed"
        fi
    else
        log_error "Claude review output file does not exist: $output_file"
        return 1
    fi
    
    # Claude should have posted the review comment directly via 'gh pr comment'
    log_success "PR review completed - Claude should have posted comment via 'gh pr comment' command"
    
    # Check if Claude made any unauthorized changes (shouldn't happen)
    if ! git diff --quiet; then
        log_warning "Claude made unexpected changes during PR review - discarding..."
        git reset --hard
    fi
    
    log_success "Completed automated review for PR #${pr_number}"
    return 0
}

# Process a single task (issue or PR) with full automation
process_single_task() {
    local number="$1"
    local mode="$2"
    local project_info="$3"
    local claude_context="$4"
    local is_range_mode="$5"
    local auto_pr_review="$6"
    
    local task_type
    if [ "$mode" = "implement" ]; then
        task_type="issue"
        log_range "Processing issue #${number}..."
    else
        task_type="pr"
        log_range "Processing PR #${number}..."
    fi

    # Early exit for prompt-only mode to avoid workspace side-effects
    if [ "$PROMPT_ONLY" = true ]; then
        log_info "Prompt-only mode: skipping workspace changes..."
        
        # Generate base Lyra-Dev prompt
        log_info "Generating Lyra-Dev base prompt..."
        local base_prompt
        base_prompt=$(generate_base_lyra_prompt "$REPO_OWNER" "$REPO_NAME" "$claude_context" "$project_info")

        # Generate mode-specific prompt for preview
        local final_prompt
        if [ "$mode" = "implement" ]; then
            log_info "Fetching issue #${number} details..."
            local issue_details
            issue_details=$(gh issue view "$number" --repo "${REPO_OWNER}/${REPO_NAME}" --json title,body,labels,assignees,milestone,url,comments 2>/dev/null || {
                log_error "Could not fetch issue #${number}. Please check the issue number and your GitHub access."
                return 1
            })
            
            log_info "Adding implementation-specific instructions..."
            local implementation_addendum
            implementation_addendum=$(generate_implementation_addendum "$number" "$issue_details")
            final_prompt="${base_prompt}${implementation_addendum}"
            
            # Show two-stage prompt generation for implementation
            echo ""
            echo "==================== STAGE 1: META-PROMPT ===================="
            echo "$final_prompt"
            echo ""
            echo "==================== STAGE 2: OPTIMIZED PROMPT ===================="
            
            # Generate optimized prompt using stage 1
            local builder_json="/tmp/${task_type}-${number}-builder-preview.json"
            local builder_txt="/tmp/${task_type}-${number}-prompt-preview.txt"
            
            log_info "Running prompt-builder to show optimized output..."
            if build_prompt_with_llm "$final_prompt" "$builder_json" "$builder_txt"; then
                cat "$builder_txt"
                rm -f "$builder_json" "$builder_txt"
            else
                echo "[ERROR: Could not generate optimized prompt â€“ see $builder_json for details]"
            fi
            echo ""
            echo "====================== PROMPT PREVIEW END ========================"
        else
            # PR Review: Direct prompt (single-stage)
            log_info "Fetching PR #${number} details..."
            local pr_details
            pr_details=$(gh pr view "$number" --repo "${REPO_OWNER}/${REPO_NAME}" --json title,body,headRefName,baseRefName,author,additions,deletions,changedFiles,commits,reviewDecision,mergeable,url 2>/dev/null || {
                log_error "Could not fetch PR #${number}. Please check the PR number and your GitHub access."
                return 1
            })

            log_info "Fetching PR diff..."
            local pr_diff
            pr_diff=$(gh pr diff "$number" --repo "${REPO_OWNER}/${REPO_NAME}" 2>/dev/null || {
                log_error "Could not fetch PR diff for #${number}"
                return 1
            })
            
            log_info "Generating direct review prompt..."
            final_prompt=$(generate_review_prompt "$number" "$pr_details" "$pr_diff" "$claude_context" "$REPO_OWNER" "$REPO_NAME")
            
            # Show single-stage prompt for PR review
            echo ""
            echo "==================== DIRECT PR REVIEW PROMPT ===================="
            echo "$final_prompt"
            echo ""
            echo "====================== PROMPT PREVIEW END ========================"
        fi
        echo ""
        return 0
    fi

    # Full automation mode - workspace hygiene first
    workspace_hygiene

    # Smart branch management: only for implementation mode
    local branch_name
    local existing_pr_number=""
    if [ "$mode" = "implement" ]; then
        log_info "Setting up branch for ${task_type} #${number}..."
        
        # Try to reuse existing branch first
        local branch_setup_result
        if branch_setup_result=$(smart_branch_setup "$number" "$task_type"); then
            # Parse the result: branch_name|pr_number or just branch_name
            if [[ "$branch_setup_result" == *"|"* ]]; then
                branch_name="${branch_setup_result%|*}"
                existing_pr_number="${branch_setup_result#*|}"
                log_success "Reusing existing branch: ${branch_name} (PR #${existing_pr_number})"
            else
                branch_name="$branch_setup_result"
                log_success "Reusing existing branch: ${branch_name}"
            fi
        else
            # No existing PR found, create new timestamped branch
            log_info "No existing PR found, creating new timestamped branch..."
            if ! branch_name=$(create_branch "$number" "$task_type"); then
                log_error "Failed to create branch for ${task_type} #${number}, skipping..."
                return 1
            fi
            log_success "Created new branch: ${branch_name}"
        fi
    else
        # Review mode: stay on main branch for read-only analysis
        log_info "PR review mode: staying on main branch (read-only analysis)"
        branch_name="main"
    fi

    # Generate base Lyra-Dev prompt
    log_info "Generating Lyra-Dev base prompt..."
    local base_prompt
    base_prompt=$(generate_base_lyra_prompt "$REPO_OWNER" "$REPO_NAME" "$claude_context" "$project_info")

    # Generate mode-specific prompt
    local final_prompt
    if [ "$mode" = "implement" ]; then
        log_info "Fetching issue #${number} details..."
        local issue_details
        issue_details=$(gh issue view "$number" --repo "${REPO_OWNER}/${REPO_NAME}" --json title,body,labels,assignees,milestone,url,comments 2>/dev/null || {
            log_error "Could not fetch issue #${number}. Please check the issue number and your GitHub access."
            return 1
        })
        
        # Fetch PR feedback if working on existing PR
        local pr_feedback=""
        if [ -n "$existing_pr_number" ]; then
            log_info "Fetching PR feedback for existing PR #${existing_pr_number}..."
            pr_feedback=$(get_pr_feedback "$existing_pr_number")
            if [ -n "$pr_feedback" ]; then
                log_success "PR feedback retrieved (${#pr_feedback} characters)"
            else
                log_info "No PR feedback found"
            fi
        fi
        
        # Generate appropriate prompt based on whether we have PR feedback
        if [ -n "$existing_pr_number" ] && [ -n "$pr_feedback" ]; then
            # Direct implementation prompt for PR feedback addressing
            log_info "Generating direct PR feedback implementation prompt..."
            final_prompt=$(generate_pr_feedback_implementation_prompt "$number" "$issue_details" "$pr_feedback" "$claude_context" "$REPO_OWNER" "$REPO_NAME")
            log_info "Direct prompt generated (${#final_prompt} chars)"
        else
            # Standard Lyra-Dev meta-prompt for new implementations
            log_info "Adding implementation-specific instructions..."
            local implementation_addendum
            implementation_addendum=$(generate_implementation_addendum "$number" "$issue_details")
            final_prompt="${base_prompt}${implementation_addendum}${pr_feedback}"
            log_info "Prompt composition: base=${#base_prompt} + addendum=${#implementation_addendum} + feedback=${#pr_feedback} = ${#final_prompt} total chars"
        fi
    else
        # PR Review: Use new review_pr function
        review_pr "$number" "$claude_context" "$REPO_OWNER" "$REPO_NAME"
        return $?
    fi

    # Check if prompt generation succeeded
    if [ -z "$final_prompt" ]; then
        log_error "Failed to generate prompt for ${task_type} #${number}, skipping..."
        return 1
    fi

    # Execute Claude based on mode
    local output_file="/tmp/${task_type}-${number}-output.md"
    
    if [ "$mode" = "implement" ]; then
        # Check if we have PR feedback - if so, use direct execution, otherwise use two-stage
        if [ -n "$existing_pr_number" ] && [ -n "$pr_feedback" ]; then
            # PR feedback exists: Direct execution (like PR review mode)
            log_info "PR feedback detected - using DIRECT EXECUTION mode for ${task_type} #${number}..."
            if [ "$INTERACTIVE" = true ]; then
                log_info "Direct Claude execution in INTERACTIVE mode for ${task_type} #${number}..."
            else
                log_info "Direct Claude execution in HEADLESS mode for ${task_type} #${number}..."
            fi
            
            # Log direct prompt size before sending to Claude
            log_info "Sending direct prompt to Claude (${#final_prompt} bytes)"
            
            local run_mode=$([[ $INTERACTIVE == true ]] && echo "interactive" || echo "headless")
            if ! run_claude "$final_prompt" "$output_file" "$run_mode"; then
                log_error "Direct Claude execution failed for ${task_type} #${number}"
                return 1
            fi
        else
            # No PR feedback: Use standard two-stage execution with Gemini
            log_info "No PR feedback - using TWO-STAGE EXECUTION mode for ${task_type} #${number}..."
            local builder_json="/tmp/${task_type}-${number}-builder.json"
            local builder_txt="/tmp/${task_type}-${number}-prompt.txt"
            
            # Stage 1: Prompt-builder (generates optimized prompt)
            log_info "Stage 1: building optimized prompt for ${task_type} #${number}..."
            if ! build_prompt_with_llm "$final_prompt" "$builder_json" "$builder_txt"; then
                log_error "Prompt builder failed for ${task_type} #${number} â€“ see $builder_json for details"
                return 1
            fi
            log_success "Optimized prompt captured"

            # Stage 2: Executor Claude (audit and implement)
            if [ "$INTERACTIVE" = true ]; then
                log_info "Stage 2: executor Claude in INTERACTIVE mode for ${task_type} #${number}..."
            else
                log_info "Stage 2: executor Claude in HEADLESS mode for ${task_type} #${number}..."
            fi
            
            # Log optimized prompt size before sending to Claude
            local optimized_prompt_size=$(wc -c < "$builder_txt" 2>/dev/null || echo "0")
            log_info "Sending optimized prompt to Claude (${optimized_prompt_size} bytes)"
            
            local run_mode=$([[ $INTERACTIVE == true ]] && echo "interactive" || echo "headless")
            if ! run_claude "$(cat "$builder_txt")" "$output_file" "$run_mode"; then
                log_error "Executor Claude failed for ${task_type} #${number}"
                return 1
            fi

            # Verify we got actual audit results, not another meta-prompt
            if grep -q 'OPTIMIZED PROMPT FOR CLAUDE\|# Lyra-Dev:' "$output_file"; then
                log_error "Executor returned another meta-prompt â€“ check addendum wording"
                return 1
            fi

            # Clean up intermediate files
            rm -f "$builder_json" "$builder_txt"
        fi
    else
        # PR Review: Single-stage direct execution
        if [ "$INTERACTIVE" = true ]; then
            log_info "Direct Claude execution in INTERACTIVE mode for PR review #${number}..."
        else
            log_info "Direct Claude execution in HEADLESS mode for PR review #${number}..."
        fi
        
        # Log PR review prompt size before sending to Claude
        log_info "Sending PR review prompt to Claude (${#final_prompt} bytes)"
        
        local run_mode=$([[ $INTERACTIVE == true ]] && echo "interactive" || echo "headless")
        if ! run_claude "$final_prompt" "$output_file" "$run_mode"; then
            log_error "Claude execution failed for PR review #${number}"
            return 1
        fi
    fi

    log_success "Claude execution completed for ${task_type} #${number}"
    
    # Log final output file details before processing
    if [ -f "$output_file" ]; then
        local final_output_size=$(wc -c < "$output_file" 2>/dev/null || echo "0")
        log_info "Final Claude output file: $output_file (${final_output_size} bytes)"
        if [ "$final_output_size" -eq 0 ]; then
            log_warning "Claude output file is empty - comments will be truncated"
        fi
    else
        log_error "Claude output file does not exist: $output_file"
    fi

    # Handle comments and results based on mode
    if [ "$mode" = "implement" ]; then
        # Implementation mode: post audit comment on issue
        issue_comment "$number" "$output_file" "$mode"
        
        # Enhanced change detection with debugging
        log_info "Checking for changes..."
        
        local has_uncommitted_changes=false
        local has_branch_commits=false
        local current_branch=$(git branch --show-current)
        
        # Check for uncommitted changes
        if ! git diff --quiet; then
            has_uncommitted_changes=true
            log_info "Found uncommitted changes in working directory"
        else
            log_info "No uncommitted changes found"
        fi
        
        # Check for commits on current branch vs main/master
        local main_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
        local commit_count=$(git rev-list --count HEAD ^origin/$main_branch 2>/dev/null || echo "0")
        
        if [ "$commit_count" -gt 0 ]; then
            has_branch_commits=true
            log_info "Found $commit_count commits on branch '$current_branch' vs '$main_branch'"
            log_info "Recent commits:"
            git log --oneline -n 3 HEAD ^origin/$main_branch 2>/dev/null || log_info "Could not show recent commits"
        else
            log_info "No commits found on current branch vs $main_branch"
        fi
        
        # Determine next action based on detected changes
        if [ "$has_uncommitted_changes" = false ] && [ "$has_branch_commits" = false ]; then
            log_info "No implementation work performed by Claude"
            log_info "This could indicate: issue already resolved, no work needed, or implementation error"
            log_info "Leaving issue #${number} open for manual review"
            return 0
        fi
        
        # We have either uncommitted changes or branch commits - proceed with workflow
        if [ "$has_branch_commits" = true ] && [ "$has_uncommitted_changes" = false ]; then
            log_info "Found existing commits - will create/update PR with existing work"
        fi

        log_info "Changes detected, proceeding with commit and PR creation..."
        log_info "Change summary: uncommitted=$has_uncommitted_changes, branch_commits=$has_branch_commits"

        # Always commit and push changes (we know changes exist at this point)
        if ! commit_and_push "$branch_name" "$number" "$mode"; then
            log_error "Failed to commit/push changes for ${task_type} #${number}"
            return 1
        fi

        # Create PR only if commits exist (we know they do since we detected changes)
        if ! git diff --quiet main...HEAD; then
            local created_pr_number
            created_pr_number=$(ensure_pr "$number" "$branch_name" "$mode" "$output_file")
            local ensure_pr_result=$?
            
            if [ $ensure_pr_result -ne 0 ]; then
                log_error "Failed to create/update PR for ${task_type} #${number}"
                return 1
            fi
            
            # Auto-review the created/updated PR if flag is set
            if [ "$auto_pr_review" = true ] && [ -n "$created_pr_number" ] && [ "$created_pr_number" != "" ]; then
                log_info "ðŸ¤– Auto-reviewing created/updated PR #${created_pr_number}..."
                if ! review_pr "$created_pr_number" "$claude_context" "$REPO_OWNER" "$REPO_NAME"; then
                    log_warning "Auto-review failed for PR #${created_pr_number}, but issue implementation was successful"
                    # Don't return error - issue implementation succeeded, review failure is not critical
                fi
            fi
        else
            log_info "No commits found relative to main â†’ PR not needed"
        fi
    fi

    log_success "Completed full automation workflow for ${task_type} #${number}"
    return 0
}

# Main execution
main() {
    # Check if no arguments provided
    if [ $# -eq 0 ]; then
        show_usage
        exit 1
    fi

    # Parse arguments
    parse_arguments "$@"

    # Check dependencies
    log_info "Checking dependencies..."
    check_dependencies "$PROMPT_ONLY"

    # Validate environment
    log_info "Validating environment..."
    validate_environment
    
    # Quick test of selected coder CLI
    if [ "$PROMPT_ONLY" != "true" ]; then
        log_info "Testing $CODER CLI..."
        local test_output
        local test_cmd
        
        if [ "$CODER" = "codex" ]; then
            test_cmd="codex exec --model o3 --dangerously-bypass-approvals-and-sandbox"
        else
            test_cmd="claude -p --model sonnet --dangerously-skip-permissions --output-format json"
        fi
        
        test_output=$(echo "Say 'test ok' and nothing else" | $test_cmd 2>&1)
        local test_exit=$?
        
        if [ $test_exit -ne 0 ]; then
            log_error "$CODER CLI test failed with exit code $test_exit"
            log_error "Output: $test_output"
            log_error "Please check your $CODER CLI installation and authentication"
            exit 1
        fi
        
        if [[ "$test_output" == *"test ok"* ]] || [[ "$test_output" == *"result"* ]]; then
            log_success "Claude CLI test passed"
        else
            log_warning "Claude CLI test returned unexpected output: ${test_output:0:100}..."
        fi
    fi

    # Get repository information
    log_info "Extracting repository information..."
    get_repo_info

    # Get project information if specified
    local project_info
    project_info=$(get_project_info "$PROJECT_ID")

    # Get CLAUDE.md context
    local claude_context
    claude_context=$(get_claude_context)

    # Handle bug report mode separately
    if [ "$MODE" = "bug" ]; then
        log_info "Processing bug report: \"$BUG_DESCRIPTION\""
        
        # Generate bug analysis prompt
        log_info "Generating bug analysis prompt..."
        local bug_prompt
        bug_prompt=$(generate_bug_analysis_prompt "$BUG_DESCRIPTION" "$claude_context" "$REPO_OWNER" "$REPO_NAME")
        
        if [ "$PROMPT_ONLY" = true ]; then
            echo "========================================"
            echo "BUG ANALYSIS PROMPT"
            echo "========================================"
            echo "$bug_prompt"
            echo ""
            echo "========================================"
            log_info "Use without --prompt-only to execute this prompt with $CODER"
            exit 0
        fi
        
        # Execute Claude with bug analysis prompt
        log_info "Running $CODER for bug analysis..."
        
        local bug_output="/tmp/bug-analysis-$$.md"
        local interactive_flag=$([[ $INTERACTIVE == true ]] && echo "true" || echo "false")
        
        if execute_coder "$bug_prompt" "$bug_output" "$interactive_flag"; then
            log_success "Bug analysis and GitHub issue creation completed"
            log_info "Check GitHub for the newly created bug report issue"
            rm -f "$bug_output"
        else
            log_error "Bug analysis failed"
            rm -f "$bug_output"
            exit 1
        fi
        
        exit 0
    fi

    # Determine what we're processing
    local numbers_to_process
    local is_range_mode=false
    
    if [ "$MODE" = "implement" ]; then
        numbers_to_process=$(parse_range "$ISSUE_RANGE")
        if [[ $ISSUE_RANGE =~ - ]]; then
            is_range_mode=true
            log_range "Processing issue range: $ISSUE_RANGE (timeout: ${TIMEOUT_SECONDS}s between tasks)"
        else
            log_info "Processing single issue: $ISSUE_RANGE"
        fi
    else
        numbers_to_process=$(parse_range "$PR_RANGE")
        if [[ $PR_RANGE =~ - ]]; then
            is_range_mode=true
            log_range "Processing PR range: $PR_RANGE (timeout: ${TIMEOUT_SECONDS}s between tasks)"
        else
            log_info "Processing single PR: $PR_RANGE"
        fi
    fi

    # Process each number
    local total_count=0
    local success_count=0
    local failed_count=0
    
    while IFS= read -r number; do
        total_count=$((total_count + 1))
        
        if [ $total_count -gt 1 ] && [ "$is_range_mode" = true ]; then
            log_range "Waiting ${TIMEOUT_SECONDS} seconds before next task..."
            sleep "$TIMEOUT_SECONDS"
        fi
        
        echo ""
        echo "========================================"
        if [ "$MODE" = "implement" ]; then
            echo "TASK $total_count: ISSUE #$number"
        else
            echo "TASK $total_count: PR #$number"
        fi
        echo "========================================"
        
        if process_single_task "$number" "$MODE" "$project_info" "$claude_context" "$is_range_mode" "$AUTO_PR_REVIEW"; then
            success_count=$((success_count + 1))
        else
            failed_count=$((failed_count + 1))
        fi
        
    done <<< "$numbers_to_process"

    echo ""
    echo "========================================"
    echo "BATCH PROCESSING COMPLETE"
    echo "========================================"
    log_info "Total tasks: $total_count"
    log_success "Successful: $success_count"
    if [ $failed_count -gt 0 ]; then
        log_error "Failed: $failed_count"
    fi
    echo ""
    
    if [ "$PROMPT_ONLY" = true ]; then
        log_info "Use without --prompt-only to execute these prompts with Claude Code"
    elif [ "$is_range_mode" = true ]; then
        if [ "$INTERACTIVE" = true ]; then
            log_info "All tasks completed in interactive mode."
        else
            log_info "All tasks completed in headless mode."
        fi
        log_info "Check GitHub for:"
        log_info "  - PR review comments posted via 'gh pr comment' (for PR reviews)"
        log_info "  - Issue audit comments and auto-closures (if complete)"
        log_info "  - New timestamped branches: issue-<number>-<timestamp> (implementation mode only)"
        log_info "  - Automated PRs created/updated (implementation mode only, when code changes exist)"
    else
        # Single task
        if [ "$INTERACTIVE" = true ]; then
            log_info "Single task completed in interactive mode."
        else
            log_info "Single task completed in headless mode."
        fi
        log_info "Check GitHub for results:"
        log_info "  - PR review comments (for PR reviews) or implementation PRs (for issues)"
    fi
}

# Run main function with all arguments
main "$@"
