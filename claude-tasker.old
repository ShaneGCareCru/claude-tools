#!/bin/bash

# Enhanced Claude Task Runner - Lyra-Dev powered context-aware wrapper for Claude Code
# Features:
#   - Two-stage Claude execution: prompt-builder → executor (eliminates meta-prompt issues)
#   - Lyra-Dev 4-D methodology for optimized prompt generation  
#   - CRITICAL: Status verification protocol to detect false completion claims
#   - AUDIT-AND-IMPLEMENT workflow: Claude audits and fixes gaps in one run
#   - Always comments audit results on issues/PRs for full transparency
#   - Smart PR creation: only when actual code changes are made
#   - Graceful handling of "already complete" cases (auto-closes, no unnecessary PRs)
#   - Single task or range processing (e.g., 230-250)
#   - Automatic branch creation for each task
#   - Configurable timeout between tasks for API rate limiting
#   - Interactive or headless mode support
#   - Project-aware prompts using CLAUDE.md context
#   - Gap analysis: focuses on actual missing pieces, not claimed completions
#   - Robust retry logic with exponential backoff for API limits
#
# Workflow: 
#   Issues: meta-prompt → optimized prompt → audit → implement gaps → comment → PR (if changes exist)
#   PR Reviews: direct prompt → review analysis → gh pr comment (no branches/PRs/separate comments)
#
# Usage:
#   claude-task <issue_number> [options]                                     - Audit and implement a single task
#   claude-task <start_issue>-<end_issue> [options]                         - Audit and implement a range of tasks
#   claude-task --review-pr <pr_number> [options]                           - Review a single PR (read-only analysis)
#   claude-task --review-pr <start_pr>-<end_pr> [options]                   - Review a range of PRs (read-only analysis)
#
# Requirements:
#   - Must be run from a directory containing CLAUDE.md
#   - Must be in a git repository with GitHub remote

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_range() {
    echo -e "${CYAN}[RANGE]${NC} $1"
}

# Check if required tools are available
check_dependencies() {
    local prompt_only="$1"
    local missing_tools=()

    if ! command -v gh &> /dev/null; then
        missing_tools+=("gh (GitHub CLI)")
    fi

    if ! command -v jq &> /dev/null; then
        missing_tools+=("jq (JSON processor)")
    fi

    # Only require claude command if not in prompt-only mode
    if [ "$prompt_only" != "true" ] && ! command -v claude &> /dev/null; then
        missing_tools+=("claude (Claude Code)")
    fi

    if ! command -v git &> /dev/null; then
        missing_tools+=("git")
    fi

    if [ ${#missing_tools[@]} -ne 0 ]; then
        log_error "Missing required tools:"
        printf '%s\n' "${missing_tools[@]}"
        echo ""
        echo "Please install the missing tools and try again."
        exit 1
    fi
}

# Validate environment
validate_environment() {
    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        log_error "This script must be run from within a git repository."
        exit 1
    fi

    # Check if CLAUDE.md exists
    if [ ! -f "CLAUDE.md" ]; then
        log_error "CLAUDE.md not found in current directory."
        log_error "This script must be run from a directory containing CLAUDE.md"
        exit 1
    fi

    log_success "Environment validation passed"
}

# Extract repository information from git config
get_repo_info() {
    local git_url
    git_url=$(git config --get remote.origin.url 2>/dev/null || {
        log_error "Could not find remote.origin.url in git config"
        exit 1
    })

    # Extract owner and repo from URL (handles both SSH and HTTPS)
    if [[ $git_url =~ github\.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
        REPO_OWNER="${BASH_REMATCH[1]}"
        REPO_NAME="${BASH_REMATCH[2]}"
        REPO_NAME="${REPO_NAME%.git}"  # Remove .git suffix if present
    else
        log_error "Could not parse GitHub repository from git URL: $git_url"
        exit 1
    fi

    log_info "Repository: ${REPO_OWNER}/${REPO_NAME}"
}

# Workspace hygiene - clean state before each task
workspace_hygiene() {
    log_info "Cleaning workspace..."
    git reset --hard || true
    git clean -fd || true
    
    # Ensure we're on main/master
    local main_branch
    if git show-ref --verify --quiet refs/heads/main; then
        main_branch="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        main_branch="master"
    else
        log_warning "Could not find main or master branch"
        return 0
    fi
    
    git checkout "$main_branch" || true
    git pull origin "$main_branch" || true
    log_success "Workspace cleaned and updated"
}

# Always commit and push changes (simplified - only called when changes exist)
commit_and_push() {
    local branch_name="$1"
    local number="$2"  # issue/PR number for reference
    local mode="$3"    # implement | review
    
    log_info "=== COMMIT AND PUSH DEBUG FOR ${mode} #${number} ==="
    log_info "Branch: ${branch_name}"
    log_info "Current branch: $(git branch --show-current)"
    
    # Verify we're on the expected branch
    if [ "$(git branch --show-current)" != "$branch_name" ]; then
        log_warning "WARNING: Expected to be on branch '${branch_name}' but on '$(git branch --show-current)'"
    fi
    
    log_info "Git status before staging:"
    git status --porcelain | head -10 | while read status_line; do
        log_info "  ${status_line}"
    done
    
    # Stage all changes
    log_info "Staging all changes with 'git add -A'..."
    git add -A
    
    log_info "Git status after staging:"
    git status --porcelain | head -10 | while read status_line; do
        log_info "  ${status_line}"
    done
    
    # Check what's actually staged
    if git diff --cached --quiet; then
        log_warning "No staged changes found - nothing to commit!"
        return 0
    fi
    
    # Commit (we know changes exist since this is only called after diff check)
    local commit_msg="🤖 ${branch_name}: automated changes from Claude"
    log_info "Committing with message: '${commit_msg}'"
    if git commit -m "$commit_msg"; then
        log_success "Changes committed successfully"
        local commit_hash=$(git rev-parse HEAD)
        log_info "Commit hash: ${commit_hash}"
    else
        log_error "Failed to commit changes"
        return 1
    fi
    
    # Push the branch
    log_info "Pushing branch '${branch_name}' to origin..."
    if git push -u origin "$branch_name"; then
        log_success "Branch pushed to origin: ${branch_name}"
        local remote_url
        remote_url=$(git remote get-url origin)
        log_info "Remote URL: ${remote_url}"
    else
        log_error "Failed to push branch: ${branch_name}"
        return 1
    fi
    
    log_info "=== END COMMIT AND PUSH DEBUG ==="
    return 0
}

# Create or update a PR (simplified - only called when changes exist)
ensure_pr() {
    local number="$1"        # issue or PR original number
    local branch="$2"        # branch_name
    local mode="$3"          # implement | review
    local body_file="$4"     # temp file containing Claude's output
    
    log_info "=== PR CREATION/UPDATE DEBUG FOR ${mode} #${number} ==="
    log_info "Branch: ${branch}"
    log_info "Body file: ${body_file}"
    
    # Check if PR already exists for this branch
    log_info "Checking if PR already exists for branch ${branch}..."
    if gh pr view "$branch" --repo "${REPO_OWNER}/${REPO_NAME}" &>/dev/null; then
        log_info "FOUND EXISTING PR for branch ${branch} - updating body..."
        local existing_pr_info
        existing_pr_info=$(gh pr view "$branch" --repo "${REPO_OWNER}/${REPO_NAME}" --json number,title,url)
        log_info "Existing PR details: $existing_pr_info"
        
        if gh pr edit "$branch" --repo "${REPO_OWNER}/${REPO_NAME}" --body-file "$body_file"; then
            log_success "PR updated for branch: ${branch}"
        else
            log_warning "Failed to update PR body for branch: ${branch}"
        fi
    else
        log_info "No existing PR found for branch ${branch} - creating new PR..."
        
        # Check if there are any existing PRs for this issue
        if [ "$mode" = "implement" ]; then
            log_info "Checking for other PRs that might be related to issue #${number}..."
            local related_prs
            related_prs=$(gh pr list --repo "${REPO_OWNER}/${REPO_NAME}" --search "#${number}" --json number,title,headRefName --limit 5)
            if [ "$related_prs" != "[]" ] && [ -n "$related_prs" ]; then
                log_warning "FOUND OTHER PRs THAT MENTION ISSUE #${number}:"
                echo "$related_prs" | jq -r '.[] | "  PR #\(.number): \(.title) (branch: \(.headRefName))"' 2>/dev/null || echo "$related_prs"
                log_warning "*** CREATING ANOTHER PR FOR THE SAME ISSUE - IS THIS INTENDED? ***"
            fi
        fi
        
        local title
        if [ "$mode" = "implement" ]; then
            title="🤖 Issue #$number – automated implementation"
        else
            title="🤖 PR #$number – automated review"
        fi
        
        local main_branch="main"
        if ! git show-ref --verify --quiet refs/heads/main; then
            main_branch="master"
        fi
        
        log_info "Creating PR: title='${title}', base='${main_branch}', head='${branch}'"
        if gh pr create --repo "${REPO_OWNER}/${REPO_NAME}" --base "$main_branch" --head "$branch" \
                        --title "$title" --body-file "$body_file" >/dev/null; then
            local new_pr_url
            new_pr_url=$(gh pr view "$branch" --repo "${REPO_OWNER}/${REPO_NAME}" --json url -q .url)
            log_success "NEW PR created for branch: ${branch}"
            log_success "PR URL: ${new_pr_url}"
        else
            log_error "Failed to create PR for branch: ${branch}"
            return 1
        fi
    fi
    
    log_info "=== END PR DEBUG ==="
}

# Always comment on the issue or PR
issue_comment() {
    local number="$1"
    local body_file="$2"
    local mode="$3"  # implement | review
    
    log_info "Adding comment to ${mode} #${number}..."
    
    # Create a comment with summary (compatible capitalization)
    local mode_cap
    case $mode in
        implement) mode_cap="Implementation" ;;
        review) mode_cap="Review" ;;
        *) mode_cap="Task" ;;
    esac
    
    local comment_file="/tmp/comment-${number}.md"
    {
        echo "🤖 **Automated ${mode_cap} Complete**"
        echo ""
        echo "**Branch**: \`$(git branch --show-current)\`"
        echo "**Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo ""
        echo "## Analysis"
        echo ""
        
        # For PR reviews: include FULL analysis (no truncation)
        # For implementations: truncate to keep comments manageable
        if [ "$mode" = "review" ]; then
            # PR reviews need full analysis - no truncation!
            cat "$body_file"
        else
            # Implementation mode: truncate to first 1000 characters
            head -c 1000 "$body_file"
            if [ $(wc -c < "$body_file") -gt 1000 ]; then
                echo ""
                echo "... (output truncated, see PR for full details)"
            fi
        fi
    } > "$comment_file"
    
    if [ "$mode" = "implement" ]; then
        if gh issue comment "$number" --repo "${REPO_OWNER}/${REPO_NAME}" --body-file "$comment_file"; then
            log_success "Comment added to issue #${number}"
        else
            log_warning "Failed to add comment to issue #${number}"
        fi
    else
        if gh pr comment "$number" --repo "${REPO_OWNER}/${REPO_NAME}" --body-file "$comment_file"; then
            log_success "Comment added to PR #${number}"
        else
            log_warning "Failed to add comment to PR #${number}"
        fi
    fi
    
    rm -f "$comment_file"
}

# Optionally close issue if completely implemented
maybe_close_issue() {
    local number="$1"
    local audit_file="$2"
    
    # Check if the audit indicates completion
    if grep -q -i "NOW 100% Complete\|Fully Complete\|Implementation Complete\|Status.*Complete" "$audit_file"; then
        log_info "Detected completion indicators, attempting to close issue #${number}..."
        
        local pr_number
        pr_number=$(gh pr view --repo "${REPO_OWNER}/${REPO_NAME}" --json number -q .number 2>/dev/null || echo "unknown")
        
        if gh issue close "$number" --repo "${REPO_OWNER}/${REPO_NAME}" \
                        --comment "✅ Automated implementation complete. See PR #${pr_number} for details." 2>/dev/null; then
            log_success "Issue #${number} closed automatically"
        else
            log_info "Could not auto-close issue #${number} (may already be closed or lack permissions)"
        fi
    else
        log_info "No completion indicators found, leaving issue #${number} open"
    fi
}

# Execute Claude with retry logic for rate limiting
# Helper function for timestamps
_ts() { 
    date +%s 
}

# Check if branch has no commits ahead of main
branch_is_empty() {
    # returns 0 (true) if the branch has no commits ahead of main
    git rev-list --count origin/main..HEAD >/dev/null 2>&1
    [ $? -eq 0 ] && [ "$(git rev-list --count origin/main..HEAD)" -eq 0 ]
}

# Enhanced logging for debugging branch/PR issues
debug_existing_state() {
    local number="$1"
    local mode="$2"
    
    log_info "=== DEBUGGING EXISTING STATE FOR ${mode} #${number} ==="
    
    if [ "$mode" = "implement" ]; then
        # Check for existing PRs linked to this issue
        log_info "Checking for existing PRs linked to issue #${number}..."
        local linked_prs
        linked_prs=$(gh pr list --repo "${REPO_OWNER}/${REPO_NAME}" --search "closes:#${number} OR fixes:#${number} OR issue #${number}" --json number,title,headRefName,state 2>/dev/null || echo "[]")
        
        if [ "$linked_prs" != "[]" ] && [ -n "$linked_prs" ]; then
            log_warning "FOUND EXISTING PRs FOR ISSUE #${number}:"
            echo "$linked_prs" | jq -r '.[] | "  PR #\(.number): \(.title) (branch: \(.headRefName), state: \(.state))"' 2>/dev/null || echo "$linked_prs"
        else
            log_info "No existing PRs found for issue #${number}"
        fi
        
        # Check for existing branches that might be related
        log_info "Checking for existing branches related to issue #${number}..."
        local related_branches
        related_branches=$(git branch -r | grep -E "issue-${number}|${number}" | head -5 || true)
        
        if [ -n "$related_branches" ]; then
            log_warning "FOUND EXISTING BRANCHES RELATED TO ISSUE #${number}:"
            echo "$related_branches" | while read branch; do
                log_warning "  ${branch}"
            done
        else
            log_info "No existing branches found for issue #${number}"
        fi
    fi
    
    # Show current branch and status
    log_info "Current branch: $(git branch --show-current)"
    log_info "Current working tree status:"
    if git diff --quiet; then
        log_info "  Working tree is clean"
    else
        log_warning "  Working tree has uncommitted changes!"
        git status --porcelain | head -10 | while read status_line; do
            log_warning "    ${status_line}"
        done
    fi
    
    log_info "=== END DEBUGGING STATE ==="
}

# Run Claude and capture clean output to file while showing colors on screen
run_claude() {
    local prompt="$1"
    local outfile="$2" 
    local mode="$3"  # mode: interactive|headless

    local claude_cmd=(claude --model sonnet --dangerously-skip-permissions)
    [[ $mode == headless ]] && claude_cmd+=( -p )

    # Use timeout for headless mode to prevent hanging, but allow unlimited time for interactive
    if [[ $mode == headless ]]; then
        # Strip ANSI from the file, keep colours on screen
        printf "%s\n" "$prompt" \
            | timeout 600s "${claude_cmd[@]}" \
            | tee >(sed -E 's/\x1B\[[0-9;]*[mK]//g' >"$outfile")
        
        local exit_code=$?
        if [ $exit_code -eq 124 ]; then
            echo "[ERROR] Claude execution timed out after 600 seconds in headless mode." >&2
            return 1
        elif [ $exit_code -ne 0 ]; then
            echo "[ERROR] Claude execution failed with exit code $exit_code" >&2
            return 1
        fi
    else
        # Interactive mode - no timeout
        printf "%s\n" "$prompt" \
            | "${claude_cmd[@]}" \
            | tee >(sed -E 's/\x1B\[[0-9;]*[mK]//g' >"$outfile")
    fi
}

# ---------- Prompt-builder helpers ----------

# (a) run first Claude pass and capture raw JSON + extracted text
build_prompt_with_claude() {
    local meta_prompt="$1"
    local json_out="$2"
    local text_out="$3"

    # Use timeout command to prevent hanging on large prompts
    printf '%s\n' "$meta_prompt" \
        | timeout 300s claude -p --model sonnet --dangerously-skip-permissions --output-format json \
        | tee >(jq '.' >"$json_out") \
        | jq -r '
            # Debug: let user see what fields are available
            (if env.DEBUG then . else empty end),
            # 2025-06 CLI shape - try multiple possible locations
            if (.result? // "") != "" then .result
            elif (.response? // "") != "" then .response  
            elif (.content? // "") != "" then .content
            elif (.text? // "") != "" then .text
            # 2025-02 "message.content" shape
            elif (.choices[0].message.content? // "") != "" then .choices[0].message.content
            # 2025-04 "content" rename
            elif (.choices[0].content? // "") != "" then .choices[0].content
            # 2024 shape
            elif (.choices[0].text? // "") != "" then .choices[0].text
            # Last resort: try to find ANY non-empty string field
            elif (.choices[0]? // {} | to_entries[] | select(.value | type == "string" and length > 0) | .value) then (.choices[0]? // {} | to_entries[] | select(.value | type == "string" and length > 0) | .value | first)
            else empty end
        ' >"$text_out"

    # Check for timeout or other failures
    local exit_code=$?
    if [ $exit_code -eq 124 ]; then
        echo "[ERROR] Claude command timed out after 300 seconds. Prompt may be too complex." >&2
        return 1
    elif [ $exit_code -ne 0 ]; then
        echo "[ERROR] Claude command failed with exit code $exit_code" >&2
        return 1
    fi

    # Fail fast if no usable prompt was extracted
    if [[ ! -s $text_out ]]; then
        echo "[ERROR] Builder produced no usable prompt – aborting. Available fields in JSON:" >&2
        echo "[ERROR] $(jq -r 'keys' "$json_out" 2>/dev/null || echo "Could not parse JSON")" >&2
        return 1 
    fi
}

# (b) legacy helper - no longer used but kept for compatibility
extract_prompt_text() {
    local json_in="$1"             # /tmp/issue-N-prompt.json
    local prompt_out="$2"          # /tmp/issue-N-prompt.txt

    jq -r '
        # 2025-06 CLI shape
        if (.result? // "") != "" then .result
        # 2025-02 "message.content" shape
        elif (.choices[0].message.content? // "") != "" then .choices[0].message.content
        # 2025-04 "content" rename
        elif (.choices[0].content? // "") != "" then .choices[0].content
        # 2024 shape
        elif (.choices[0].text? // "") != "" then .choices[0].text
        else empty end
    ' "$json_in" >"$prompt_out"
}



# Create a new branch with timestamp (PURE - only outputs branch name)
create_branch() {
    local number="$1"
    local type="$2"  # "issue" or "pr"
    local branch_name

    # Use timestamped branch names to avoid conflicts on re-runs
    if [ "$type" = "issue" ]; then
        branch_name="issue-${number}-$(_ts)"
    else
        branch_name="review-pr-${number}-$(_ts)"
    fi

    # Create and checkout new branch (workspace already cleaned by workspace_hygiene)
    # Use -B to force creation/reset and checkout main as base
    if git checkout -B "$branch_name" main >/dev/null 2>&1; then
        # PURE OUTPUT: only the branch name, no logging
        echo "$branch_name"
        return 0
    else
        return 1
    fi
}

# Execute Claude with retry logic for rate limiting
execute_claude_with_retry() {
    local final_prompt="$1"
    local output_file="$2"
    local interactive="$3"
    
    log_info "Executing Claude Code with retry logic..."
    
    for attempt in {1..5}; do
        log_info "Claude attempt ${attempt}/5..."
        
        local claude_cmd
        if [ "$interactive" = true ]; then
            claude_cmd="claude --model sonnet --dangerously-skip-permissions"
        else
            claude_cmd="claude -p --model sonnet --dangerously-skip-permissions"
        fi
        
        # Execute and capture output
        if echo "$final_prompt" | $claude_cmd | tee "$output_file"; then
            log_success "Claude execution successful on attempt ${attempt}"
            return 0
        else
            local exit_code=$?
            log_warning "Claude execution failed (attempt ${attempt}/5, exit code: ${exit_code})"
            
            if [ $attempt -lt 5 ]; then
                log_info "Sleeping 90 seconds before retry due to potential rate limit..."
                sleep 90
            fi
        fi
    done
    
    log_error "Claude execution failed after 5 attempts"
    return 1
}

# Parse range syntax (e.g., "230-250" or "230")
parse_range() {
    local input="$1"
    
    if [[ $input =~ ^([0-9]+)-([0-9]+)$ ]]; then
        # Range format: start-end
        local start="${BASH_REMATCH[1]}"
        local end="${BASH_REMATCH[2]}"
        
        if [ "$start" -gt "$end" ]; then
            log_error "Invalid range: start ($start) cannot be greater than end ($end)"
            exit 1
        fi
        
        # Return array of numbers
        seq "$start" "$end"
    elif [[ $input =~ ^[0-9]+$ ]]; then
        # Single number
        echo "$input"
    else
        log_error "Invalid range format: $input (expected: number or start-end)"
        exit 1
    fi
}

# Fetch project information if project ID is provided
get_project_info() {
    local project_id="$1"
    
    if [ -z "$project_id" ]; then
        echo ""
        return
    fi

    log_info "Fetching project #${project_id} details..."
    
    local project_info
    project_info=$(gh project view "$project_id" --owner "$REPO_OWNER" --format json 2>/dev/null || {
        log_warning "Could not fetch project #${project_id}. Proceeding without project context."
        echo ""
        return
    })

    if [ -n "$project_info" ]; then
        log_success "Project information loaded"
        echo "$project_info"
    else
        echo ""
    fi
}

# Read and prepare CLAUDE.md content
get_claude_context() {
    if [ ! -f "CLAUDE.md" ]; then
        log_error "CLAUDE.md not found"
        exit 1
    fi

    log_info "Loading project context from CLAUDE.md..."
    cat "CLAUDE.md"
}

# Show usage information
show_usage() {
    echo "Usage:"
    echo "  $0 <github_issue_number> [options]                                   - Implement a single task"
    echo "  $0 <start_issue>-<end_issue> [options]                              - Implement a range of tasks"
    echo "  $0 --review-pr <pr_number> [options]                                - Review a single PR"
    echo "  $0 --review-pr <start_pr>-<end_pr> [options]                        - Review a range of PRs"
    echo ""
    echo "Options:"
    echo "  --project <id>      Include GitHub project context (optional)"
    echo "  --prompt-only       Generate and display the prompt without executing Claude Code"
    echo "  --timeout <seconds> Sleep between tasks in range mode (default: 30 seconds)"
    echo "  --interactive       Use interactive Claude Code mode instead of headless (-p) mode"
    echo ""
    echo "Examples:"
    echo "  $0 316                                    # Audit and implement single issue (headless)"
    echo "  $0 230-250                               # Audit and implement range of issues (headless)"
    echo "  $0 230-250 --timeout 60                 # Range with 60s timeout between tasks"
    echo "  $0 316 --project 3                      # With project context"
    echo "  $0 316 --prompt-only                    # Generate Lyra-Dev prompt only"
    echo "  $0 316 --interactive                    # Single issue with interactive mode"
    echo "  $0 --review-pr 329                      # Review single PR (read-only analysis)"
    echo "  $0 --review-pr 325-330                  # Review range of PRs (read-only analysis)"
    echo "  $0 --review-pr 325-330 --timeout 45     # Range with 45s timeout"
    echo "  $0 --review-pr 329 --interactive        # Interactive PR review (posts comment)"
    echo ""
    echo "Requirements:"
    echo "  - Must be run from a directory containing CLAUDE.md"
    echo "  - Must be in a git repository with GitHub remote"
    echo "  - Requires: gh (GitHub CLI), git, claude (Claude Code), jq (JSON processor)"
    echo ""
    echo "Range Mode Features:"
    echo "  - TWO-STAGE EXECUTION for ISSUES: prompt-builder Claude → executor Claude (eliminates meta-prompts)"
    echo "  - SINGLE-STAGE EXECUTION for PR REVIEWS: direct review prompt → gh pr comment"
    echo "  - IMPLEMENTATION MODE: Claude audits and fixes gaps in one run (creates branches/PRs)"
    echo "  - REVIEW MODE: Direct PR analysis with actionable feedback via GitHub CLI comments"
    echo "  - Issue comments: posts audit results for transparency (implementation mode only)"
    echo "  - Smart PR creation: only when actual code changes are made (implementation mode only)"
    echo "  - Creates timestamped branches for each task (implementation mode only)"
    echo "  - Auto-closes issues when audit shows they're already complete"
    echo "  - Gracefully handles mixed scenarios (some complete, some need work)"
    echo "  - Automatically sleeps between tasks to prevent API rate limiting"
    echo "  - Continues processing even if individual tasks fail"
    echo "  - Use --interactive for manual control of each Claude Code session"
    echo "  - Default headless mode (-p) processes tasks automatically"
    echo "  - Uses Lyra-Dev framework for optimized prompt generation (implementation mode)"
    echo "  - CRITICAL: Status verification prevents duplicate work on 'completed' tasks"
    echo "  - Robust retry logic with exponential backoff for API rate limits"
}

# Parse command line arguments
parse_arguments() {
    MODE=""
    ISSUE_RANGE=""
    PR_RANGE=""
    PROJECT_ID=""
    PROMPT_ONLY=false
    INTERACTIVE=false
    TIMEOUT_SECONDS=30  # Default timeout

    while [[ $# -gt 0 ]]; do
        case $1 in
            --review-pr)
                if [ -n "$MODE" ]; then
                    log_error "Cannot specify both --review-pr and issue number/range"
                    exit 1
                fi
                MODE="review"
                shift
                if [[ $# -gt 0 && ($1 =~ ^[0-9]+$ || $1 =~ ^[0-9]+-[0-9]+$) ]]; then
                    PR_RANGE="$1"
                    shift
                else
                    log_error "--review-pr requires a PR number or range (e.g., 325 or 325-330)"
                    exit 1
                fi
                ;;
            --project)
                shift
                if [[ $# -gt 0 && $1 =~ ^[0-9]+$ ]]; then
                    PROJECT_ID="$1"
                    shift
                else
                    log_error "--project requires a project ID"
                    exit 1
                fi
                ;;
            --prompt-only)
                PROMPT_ONLY=true
                shift
                ;;
            --interactive)
                INTERACTIVE=true
                shift
                ;;
            --timeout)
                shift
                if [[ $# -gt 0 && $1 =~ ^[0-9]+$ ]]; then
                    TIMEOUT_SECONDS="$1"
                    shift
                else
                    log_error "--timeout requires a number of seconds"
                    exit 1
                fi
                ;;
            --help|-h)
                show_usage
                exit 0
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                # This should be an issue number or range for implementation mode
                if [[ $1 =~ ^[0-9]+$ || $1 =~ ^[0-9]+-[0-9]+$ ]]; then
                    if [ -n "$MODE" ]; then
                        log_error "Cannot specify both issue number/range and --review-pr"
                        exit 1
                    fi
                    MODE="implement"
                    ISSUE_RANGE="$1"
                    shift
                else
                    log_error "Invalid argument: $1 (expected: number, range, or --review-pr)"
                    show_usage
                    exit 1
                fi
                ;;
        esac
    done

    # Validate arguments
    if [ -z "$MODE" ]; then
        log_error "No command specified"
        show_usage
        exit 1
    fi

    if [ "$MODE" = "implement" ] && [ -z "$ISSUE_RANGE" ]; then
        log_error "Issue number or range required for implementation mode"
        exit 1
    fi

    if [ "$MODE" = "review" ] && [ -z "$PR_RANGE" ]; then
        log_error "PR number or range required for review mode"
        exit 1
    fi

    if [ -n "$PROJECT_ID" ] && ! [[ "$PROJECT_ID" =~ ^[0-9]+$ ]]; then
        log_error "Project ID must be a positive integer"
        exit 1
    fi

    if ! [[ "$TIMEOUT_SECONDS" =~ ^[0-9]+$ ]]; then
        log_error "Timeout must be a positive integer (seconds)"
        exit 1
    fi

    # Validate conflicting options
    if [ "$PROMPT_ONLY" = true ] && [ "$INTERACTIVE" = true ]; then
        log_error "Cannot use --prompt-only and --interactive together"
        exit 1
    fi
}

# Generate the base Lyra-Dev prompt framework
generate_base_lyra_prompt() {
    local repo_owner="$1"
    local repo_name="$2"
    local claude_context="$3"
    local project_info="$4"

    cat << 'EOF'
# Lyra-Dev: Claude-Compatible Prompt Optimizer for Software Tasks

You are **Lyra-Dev**, an elite AI prompt optimizer embedded in a dev workflow. Your role is to transform stitched-together context — from READMEs, codebase rules, and tasks (e.g. kanban cards, PRs) — into a **fully-formed, self-reliant prompt** tailored for Claude (Code model), ready for autonomous execution with no back-and-forth interaction.

You never ask questions. Instead, you **reason through missing details**, assume safe defaults, and state those assumptions in the output. Your prompts must always be actionable, context-aware, and structured.

---

## 🔄 THE 4-D METHODOLOGY (Headless Software Edition)

### 1. DECONSTRUCT
- Extract task intent, key entities (files, services, APIs), and project context.
- Identify output requirements: code, test, rationale, config, etc.
- Map what is provided vs. what is missing (README, rules, task description).

### 2. DIAGNOSE
- Check for ambiguity or unclear expectations.
- **CRITICAL: Verify claimed completion status** - Many tasks claim to be "done" when they're not.
- Identify missing constraints or implicit assumptions.
- **Gap Analysis**: Compare claimed vs actual implementation state.
- If any required information is absent, infer it from surrounding context or apply safe defaults.

### 3. DEVELOP
- Select the right approach based on task type:
  - **Bug Fixes** → Constraint-based logic, minimal change, clarity
  - **New Features** → Step-by-step reasoning, layered context
  - **Refactors** → Chain-of-thought logic + pattern recognition
  - **PR Reviews** → Multi-perspective analysis + rules enforcement
  - **Status Verification** → Audit claimed vs actual, focus on gaps only
- Assign a role to Claude (e.g. "Act as a senior backend engineer").
- Embed project rules, output format requirements, and tone (if applicable).

### 4. DELIVER
- Output the optimized prompt in a structured format.
- Embed context, clarify assumptions, and specify the expected format of the Claude response.
- Provide an optional "Optimization Notes" section for tracking what changed and why.

---

## ⚙️ OPTIMIZATION TECHNIQUES

**Foundation:**  
- Role assignment  
- Context layering  
- Output specification  
- Task decomposition  

**Advanced:**  
- Chain-of-thought reasoning  
- Constraint optimization  
- Multi-perspective evaluation  
- Few-shot learning (if examples are available)  

---

## 🤖 TARGET PLATFORM: CLAUDE (Code)

- Long-form reasoning supported  
- Handles layered context well  
- Responds best to clearly scoped, structured tasks  
- Avoid ambiguous phrasing or unstated expectations  

---

## 🔁 EXECUTION LOGIC (Automated Flow)

1. Auto-detect task complexity from input.
2. Apply DETAIL mode logic (self-contained reasoning).
3. Never ask the user questions. Instead, note assumptions and proceed.
4. Deliver prompt using the structure below.

---
EOF

    echo ""
    echo "## 📋 PROJECT CONTEXT"
    echo ""
    echo "**Repository:** ${repo_owner}/${repo_name}"
    echo ""
    echo "### Project Guidelines (CLAUDE.md)"
    echo '```'
    echo "$claude_context"
    echo '```'
    echo ""
    
    if [ -n "$project_info" ]; then
        echo "### GitHub Project Context"
        echo '```json'
        echo "$project_info"
        echo '```'
        echo ""
    fi
}

# Generate implementation-specific addendum
generate_implementation_addendum() {
    local issue_number="$1"
    local issue_details="$2"

    cat << EOF

---

## 🛠️ IMPLEMENTATION MODE: ISSUE #${issue_number}

### TASK CONTEXT
${issue_details}

### IMPLEMENTATION REQUIREMENTS

**Role Assignment:** Act as a **senior software engineer** implementing this feature/fix.

**CRITICAL - Status Verification Protocol:**
Before any implementation work, you MUST audit the claimed completion status:

1. **Verify Claims vs Reality**: The issue claims certain completion levels - these may be inaccurate
2. **Investigate Actual Implementation**: Check the codebase for actual feature implementation
3. **Gap Analysis**: Identify what's actually missing vs what's claimed to be done
4. **Focus on Gaps**: Only implement what's actually missing, don't duplicate existing work

**Context Priority:**
1. Follow all guidelines specified in CLAUDE.md
2. Maintain existing project patterns and conventions
3. Use terraform for GCP resource management (if applicable)
4. Write comprehensive tests following project testing patterns
5. Ensure backwards compatibility unless explicitly breaking change

**Output Format Required:**
\`\`\`
# DECONSTRUCT
[Analysis of what the issue claims vs what actually needs to be built]

# DIAGNOSE  
[Status verification: What's claimed vs actual implementation state]
[Assumptions made about implementation approach, missing details]

# DEVELOP
[Step-by-step plan focusing ONLY on actual gaps/missing pieces]

# DELIVER
[Implementation of missing pieces only, tests, and documentation]

# STATUS AUDIT
- **Claimed Status**: [What the issue claims to be done]
- **Actual Status**: [What you found in the codebase]
- **Work Required**: [Specific gaps that need to be filled]
- **Approach**: [Complete missing pieces vs full reimplementation]

# COMPLETION CHECKLIST
- [ ] Status verification completed - identified actual vs claimed implementation
- [ ] Gap analysis performed - focused only on missing pieces
- [ ] Code implements the missing functionality (not duplicating existing work)
- [ ] Tests written for new/missing functionality
- [ ] Documentation updated for changes made
- [ ] Code follows project conventions from CLAUDE.md
- [ ] Ready for PR creation

# FINAL STEP: CREATE PULL REQUEST
Create a detailed PR with:
- Clear description of what gaps were filled (not "implemented feature")
- Link to issue #${issue_number}
- Status audit summary (claimed vs actual vs completed)
- Testing notes for new functionality only
- Any breaking changes or migration notes
\`\`\`

**Critical Instructions:**
1. **NEVER take issue status claims at face value** - always verify by examining the codebase
2. **Focus on gaps, not greenfield implementation** - most "incomplete" features are partially done
3. **Document status discrepancies** - note when claimed status doesn't match reality
4. **Be surgical in your changes** - only implement what's actually missing
5. **AUDIT AND IMPLEMENT IN ONE RUN** - conduct the mandatory status verification and, in the same run, implement every gap you identify. The working tree must end in a fully gap-filled state, complete with tests and docs.

Begin conducting status verification and implementing all identified gaps for issue #${issue_number} using the 4-D methodology.
EOF
}

# Generate PR review-specific prompt (SIMPLIFIED - direct execution, no meta-prompt)
generate_review_prompt() {
    local pr_number="$1"
    local pr_details="$2"
    local pr_diff="$3"
    local claude_context="$4"
    local repo_owner="$5"
    local repo_name="$6"

    cat << EOF
# Senior Code Review - PR #${pr_number}

You are a **senior software engineer** conducting a thorough code review of PR #${pr_number} in ${repo_owner}/${repo_name}.

## 🔄 4-D REVIEW METHODOLOGY

### 1. DECONSTRUCT
- Analyze what this PR accomplishes and its scope
- Identify the key changes, files modified, and functionality affected
- Map the changes to the project's architecture and conventions

### 2. DIAGNOSE  
- Identify potential issues, risks, or concerns in the changes
- Check for security vulnerabilities, performance impacts, and maintainability issues
- Assess adherence to project guidelines and coding standards

### 3. DEVELOP
- Provide specific, actionable feedback with file names and line numbers
- Suggest concrete improvements and alternatives
- Reference project patterns and conventions that should be followed

### 4. DELIVER
- Make final review decision: APPROVE, REQUEST_CHANGES, or COMMENT
- Use GitHub CLI to post your review with clear reasoning

---

## 📋 PROJECT CONTEXT

**Repository:** ${repo_owner}/${repo_name}

### Project Guidelines (CLAUDE.md)
\`\`\`
${claude_context}
\`\`\`

---

## 🔍 PR DETAILS

${pr_details}

---

## 📝 CODE CHANGES

\`\`\`diff
${pr_diff}
\`\`\`

---

## 📋 REVIEW REQUIREMENTS

Conduct a thorough technical review focusing on:

1. **Code Quality**: Does it follow project conventions from CLAUDE.md?
2. **Security**: Any potential vulnerabilities or security risks?
3. **Performance**: Will this impact system performance negatively?
4. **Architecture**: Is it consistent with existing patterns and design?
5. **Testing**: Are there adequate tests for the changes?
6. **Documentation**: Is documentation updated appropriately?

## 🎯 OUTPUT FORMAT

Provide your review in this exact format:

\`\`\`
# DECONSTRUCT
[What this PR does and its scope - 2-3 sentences]

# DIAGNOSE
[Issues found, concerns, or areas that need attention]

# DEVELOP
[Specific feedback with actionable suggestions]

# DELIVER

## Code Review Summary
[Brief explanation of your overall assessment]

## Issues Found
- **[filename:line]**: [specific issue and how to fix it]
- **[filename:function]**: [pattern/convention issue and correct approach]
- **[general]**: [broader concerns and recommendations]

## Recommendations
- [Actionable steps the author should take]
- [Best practices to follow based on CLAUDE.md]

## Positive Aspects
- [Things done well in this PR, if any]

\`\`\`

## 🚀 FINAL INSTRUCTION

After completing your analysis above, you MUST use the GitHub CLI to post a comment on the PR:

**Always use:**
\`gh pr comment ${pr_number} --body "YOUR_DETAILED_REVIEW_HERE"\`

**Format your comment with clear sections:**
- **Summary**: Brief overview of your assessment
- **Issues Found**: Specific problems with file:line references
- **Recommendations**: Actionable next steps for the author
- **Positive Notes**: What was done well (if applicable)

**Be specific and actionable** - engineers need to know exactly what to fix and how to fix it. Include file names, function names, line numbers, and specific code examples when possible.

Begin your review now.
EOF
}

# Smart branch management: reuse existing PR branches or create new ones
smart_branch_setup() {
    local number="$1"
    local task_type="$2"
    
    log_info "=== SMART BRANCH SETUP FOR ${task_type} #${number} ==="
    
    # Check for existing open PRs for this issue
    log_info "Checking for existing open PRs for issue #${number}..."
    local existing_prs
    existing_prs=$(gh pr list --repo "${REPO_OWNER}/${REPO_NAME}" --search "closes:#${number} OR fixes:#${number} OR issue #${number}" --state open --json number,title,headRefName 2>/dev/null || echo "[]")
    
    if [ "$existing_prs" != "[]" ] && [ -n "$existing_prs" ]; then
        # Found existing PR(s) - use the first one
        local existing_branch
        existing_branch=$(echo "$existing_prs" | jq -r '.[0].headRefName' 2>/dev/null)
        local existing_pr_number
        existing_pr_number=$(echo "$existing_prs" | jq -r '.[0].number' 2>/dev/null)
        
        if [ -n "$existing_branch" ] && [ "$existing_branch" != "null" ]; then
            log_success "FOUND EXISTING OPEN PR #${existing_pr_number} with branch: ${existing_branch}"
            log_info "REUSING existing branch instead of creating new one..."
            
            # Fetch the branch from remote
            log_info "Fetching existing branch from remote..."
            git fetch origin "$existing_branch" || {
                log_warning "Could not fetch branch ${existing_branch}, will create new one"
                return 1
            }
            
            # Checkout the existing branch
            if git checkout "$existing_branch" >/dev/null 2>&1; then
                log_success "Switched to existing branch: ${existing_branch}"
                
                # Pull latest changes
                log_info "Pulling latest changes from origin/${existing_branch}..."
                git pull origin "$existing_branch" || {
                    log_warning "Could not pull latest changes, continuing anyway"
                }
                
                echo "$existing_branch"  # Return the existing branch name
                return 0
            else
                log_warning "Could not checkout existing branch ${existing_branch}, will create new one"
                return 1
            fi
        else
            log_warning "Could not extract branch name from existing PR, will create new one"
            return 1
        fi
    else
        log_info "No existing open PRs found for issue #${number}"
        return 1  # Signal to create new branch
    fi
}

# Process a single task (issue or PR) with full automation
process_single_task() {
    local number="$1"
    local mode="$2"
    local project_info="$3"
    local claude_context="$4"
    local is_range_mode="$5"
    
    local task_type
    if [ "$mode" = "implement" ]; then
        task_type="issue"
        log_range "Processing issue #${number}..."
    else
        task_type="pr"
        log_range "Processing PR #${number}..."
    fi

    # Early exit for prompt-only mode to avoid workspace side-effects
    if [ "$PROMPT_ONLY" = true ]; then
        log_info "Prompt-only mode: skipping workspace changes..."
        
        # Generate base Lyra-Dev prompt
        log_info "Generating Lyra-Dev base prompt..."
        local base_prompt
        base_prompt=$(generate_base_lyra_prompt "$REPO_OWNER" "$REPO_NAME" "$claude_context" "$project_info")

        # Generate mode-specific prompt for preview
        local final_prompt
        if [ "$mode" = "implement" ]; then
            log_info "Fetching issue #${number} details..."
            local issue_details
            issue_details=$(gh issue view "$number" --repo "${REPO_OWNER}/${REPO_NAME}" --json title,body,labels,assignees,milestone,url,comments 2>/dev/null || {
                log_error "Could not fetch issue #${number}. Please check the issue number and your GitHub access."
                return 1
            })
            
            log_info "Adding implementation-specific instructions..."
            local implementation_addendum
            implementation_addendum=$(generate_implementation_addendum "$number" "$issue_details")
            final_prompt="${base_prompt}${implementation_addendum}"
            
            # Show two-stage prompt generation for implementation
            echo ""
            echo "==================== STAGE 1: META-PROMPT ===================="
            echo "$final_prompt"
            echo ""
            echo "==================== STAGE 2: OPTIMIZED PROMPT ===================="
            
            # Generate optimized prompt using stage 1
            local builder_json="/tmp/${task_type}-${number}-builder-preview.json"
            local builder_txt="/tmp/${task_type}-${number}-prompt-preview.txt"
            
            log_info "Running prompt-builder to show optimized output..."
            if build_prompt_with_claude "$final_prompt" "$builder_json" "$builder_txt"; then
                cat "$builder_txt"
                rm -f "$builder_json" "$builder_txt"
            else
                echo "[ERROR: Could not generate optimized prompt – see $builder_json for details]"
            fi
            echo ""
            echo "====================== PROMPT PREVIEW END ========================"
        else
            # PR Review: Direct prompt (single-stage)
            log_info "Fetching PR #${number} details..."
            local pr_details
            pr_details=$(gh pr view "$number" --repo "${REPO_OWNER}/${REPO_NAME}" --json title,body,headRefName,baseRefName,author,additions,deletions,changedFiles,commits,reviewDecision,mergeable,url 2>/dev/null || {
                log_error "Could not fetch PR #${number}. Please check the PR number and your GitHub access."
                return 1
            })

            log_info "Fetching PR diff..."
            local pr_diff
            pr_diff=$(gh pr diff "$number" --repo "${REPO_OWNER}/${REPO_NAME}" 2>/dev/null || {
                log_error "Could not fetch PR diff for #${number}"
                return 1
            })
            
            log_info "Generating direct review prompt..."
            final_prompt=$(generate_review_prompt "$number" "$pr_details" "$pr_diff" "$claude_context" "$REPO_OWNER" "$REPO_NAME")
            
            # Show single-stage prompt for PR review
            echo ""
            echo "==================== DIRECT PR REVIEW PROMPT ===================="
            echo "$final_prompt"
            echo ""
            echo "====================== PROMPT PREVIEW END ========================"
        fi
        echo ""
        return 0
    fi

    # Full automation mode - workspace hygiene first
    workspace_hygiene

    # Smart branch management: only for implementation mode
    local branch_name
    if [ "$mode" = "implement" ]; then
        log_info "Setting up branch for ${task_type} #${number}..."
        
        # Try to reuse existing branch first
        if branch_name=$(smart_branch_setup "$number" "$task_type"); then
            log_success "Reusing existing branch: ${branch_name}"
        else
            # No existing PR found, create new timestamped branch
            log_info "No existing PR found, creating new timestamped branch..."
            if ! branch_name=$(create_branch "$number" "$task_type"); then
                log_error "Failed to create branch for ${task_type} #${number}, skipping..."
                return 1
            fi
            log_success "Created new branch: ${branch_name}"
        fi
    else
        # Review mode: stay on main branch for read-only analysis
        log_info "PR review mode: staying on main branch (read-only analysis)"
        branch_name="main"
    fi

    # Generate base Lyra-Dev prompt
    log_info "Generating Lyra-Dev base prompt..."
    local base_prompt
    base_prompt=$(generate_base_lyra_prompt "$REPO_OWNER" "$REPO_NAME" "$claude_context" "$project_info")

    # Generate mode-specific prompt
    local final_prompt
    if [ "$mode" = "implement" ]; then
        log_info "Fetching issue #${number} details..."
        local issue_details
        issue_details=$(gh issue view "$number" --repo "${REPO_OWNER}/${REPO_NAME}" --json title,body,labels,assignees,milestone,url,comments 2>/dev/null || {
            log_error "Could not fetch issue #${number}. Please check the issue number and your GitHub access."
            return 1
        })
        
        log_info "Adding implementation-specific instructions..."
        local implementation_addendum
        implementation_addendum=$(generate_implementation_addendum "$number" "$issue_details")
        final_prompt="${base_prompt}${implementation_addendum}"
    else
        # PR Review: Use direct prompt (no meta-prompt, no two-stage)
        log_info "Fetching PR #${number} details..."
        local pr_details
        pr_details=$(gh pr view "$number" --repo "${REPO_OWNER}/${REPO_NAME}" --json title,body,headRefName,baseRefName,author,additions,deletions,changedFiles,commits,reviewDecision,mergeable,url 2>/dev/null || {
            log_error "Could not fetch PR #${number}. Please check the PR number and your GitHub access."
            return 1
        })

        log_info "Fetching PR diff..."
        local pr_diff
        pr_diff=$(gh pr diff "$number" --repo "${REPO_OWNER}/${REPO_NAME}" 2>/dev/null || {
            log_error "Could not fetch PR diff for #${number}"
            return 1
        })
        
        log_info "Generating direct review prompt (single-stage)..."
        final_prompt=$(generate_review_prompt "$number" "$pr_details" "$pr_diff" "$claude_context" "$REPO_OWNER" "$REPO_NAME")
    fi

    # Check if prompt generation succeeded
    if [ -z "$final_prompt" ]; then
        log_error "Failed to generate prompt for ${task_type} #${number}, skipping..."
        return 1
    fi

    # Execute Claude based on mode
    local output_file="/tmp/${task_type}-${number}-output.md"
    
    if [ "$mode" = "implement" ]; then
        # Implementation: Two-stage execution (prompt-builder → executor)
        local builder_json="/tmp/${task_type}-${number}-builder.json"
        local builder_txt="/tmp/${task_type}-${number}-prompt.txt"
        
        # Stage 1: Prompt-builder Claude (generates optimized prompt)
        log_info "Stage 1: building optimized prompt for ${task_type} #${number}..."
        if ! build_prompt_with_claude "$final_prompt" "$builder_json" "$builder_txt"; then
            log_error "Prompt builder failed for ${task_type} #${number} – see $builder_json for details"
            return 1
        fi
        log_success "Optimized prompt captured"

        # Stage 2: Executor Claude (audit and implement)
        if [ "$INTERACTIVE" = true ]; then
            log_info "Stage 2: executor Claude in INTERACTIVE mode for ${task_type} #${number}..."
        else
            log_info "Stage 2: executor Claude in HEADLESS mode for ${task_type} #${number}..."
        fi
        
        local run_mode=$([[ $INTERACTIVE == true ]] && echo "interactive" || echo "headless")
        if ! run_claude "$(cat "$builder_txt")" "$output_file" "$run_mode"; then
            log_error "Executor Claude failed for ${task_type} #${number}"
            return 1
        fi

        # Verify we got actual audit results, not another meta-prompt
        if grep -q 'OPTIMIZED PROMPT FOR CLAUDE\|# Lyra-Dev:' "$output_file"; then
            log_error "Executor returned another meta-prompt – check addendum wording"
            return 1
        fi

        # Clean up intermediate files
        rm -f "$builder_json" "$builder_txt"
    else
        # PR Review: Single-stage direct execution
        if [ "$INTERACTIVE" = true ]; then
            log_info "Direct Claude execution in INTERACTIVE mode for PR review #${number}..."
        else
            log_info "Direct Claude execution in HEADLESS mode for PR review #${number}..."
        fi
        
        local run_mode=$([[ $INTERACTIVE == true ]] && echo "interactive" || echo "headless")
        if ! run_claude "$final_prompt" "$output_file" "$run_mode"; then
            log_error "Claude execution failed for PR review #${number}"
            return 1
        fi
    fi

    log_success "Claude execution completed for ${task_type} #${number}"

    # Handle comments and results based on mode
    if [ "$mode" = "implement" ]; then
        # Implementation mode: post audit comment on issue
        issue_comment "$number" "$output_file" "$mode"
        
        # Check for changes and create PRs
        if git diff --quiet; then
            log_success "Audit found no code changes needed – issue appears complete"
            # Optional: auto-close the issue if it appears complete
            maybe_close_issue "$number" "$output_file"
            return 0
        fi

        log_info "Code changes detected, proceeding with commit and PR creation..."

        # Always commit and push changes (we know changes exist at this point)
        if ! commit_and_push "$branch_name" "$number" "$mode"; then
            log_error "Failed to commit/push changes for ${task_type} #${number}"
            return 1
        fi

        # Create PR only if commits exist (we know they do since we detected changes)
        if ! git diff --quiet main...HEAD; then
            if ! ensure_pr "$number" "$branch_name" "$mode" "$output_file"; then
                log_error "Failed to create/update PR for ${task_type} #${number}"
                return 1
            fi
        else
            log_info "No commits found relative to main → PR not needed"
        fi
    else
        # Review mode: Claude should have used 'gh pr comment' directly, no separate comments needed
        log_success "PR review completed - Claude should have posted comment via 'gh pr comment' command"
        
        # Check if Claude made any unauthorized changes (shouldn't happen)
        if ! git diff --quiet; then
            log_warning "Claude made unexpected changes during PR review - discarding..."
            git reset --hard
        fi
    fi

    log_success "Completed full automation workflow for ${task_type} #${number}"
    return 0
}

# Main execution
main() {
    # Check if no arguments provided
    if [ $# -eq 0 ]; then
        show_usage
        exit 1
    fi

    # Parse arguments
    parse_arguments "$@"

    # Check dependencies
    log_info "Checking dependencies..."
    check_dependencies "$PROMPT_ONLY"

    # Validate environment
    log_info "Validating environment..."
    validate_environment

    # Get repository information
    log_info "Extracting repository information..."
    get_repo_info

    # Get project information if specified
    local project_info
    project_info=$(get_project_info "$PROJECT_ID")

    # Get CLAUDE.md context
    local claude_context
    claude_context=$(get_claude_context)

    # Determine what we're processing
    local numbers_to_process
    local is_range_mode=false
    
    if [ "$MODE" = "implement" ]; then
        numbers_to_process=$(parse_range "$ISSUE_RANGE")
        if [[ $ISSUE_RANGE =~ - ]]; then
            is_range_mode=true
            log_range "Processing issue range: $ISSUE_RANGE (timeout: ${TIMEOUT_SECONDS}s between tasks)"
        else
            log_info "Processing single issue: $ISSUE_RANGE"
        fi
    else
        numbers_to_process=$(parse_range "$PR_RANGE")
        if [[ $PR_RANGE =~ - ]]; then
            is_range_mode=true
            log_range "Processing PR range: $PR_RANGE (timeout: ${TIMEOUT_SECONDS}s between tasks)"
        else
            log_info "Processing single PR: $PR_RANGE"
        fi
    fi

    # Process each number
    local total_count=0
    local success_count=0
    local failed_count=0
    
    while IFS= read -r number; do
        total_count=$((total_count + 1))
        
        if [ $total_count -gt 1 ] && [ "$is_range_mode" = true ]; then
            log_range "Waiting ${TIMEOUT_SECONDS} seconds before next task..."
            sleep "$TIMEOUT_SECONDS"
        fi
        
        echo ""
        echo "========================================"
        if [ "$MODE" = "implement" ]; then
            echo "TASK $total_count: ISSUE #$number"
        else
            echo "TASK $total_count: PR #$number"
        fi
        echo "========================================"
        
        if process_single_task "$number" "$MODE" "$project_info" "$claude_context" "$is_range_mode"; then
            success_count=$((success_count + 1))
        else
            failed_count=$((failed_count + 1))
        fi
        
    done <<< "$numbers_to_process"

    echo ""
    echo "========================================"
    echo "BATCH PROCESSING COMPLETE"
    echo "========================================"
    log_info "Total tasks: $total_count"
    log_success "Successful: $success_count"
    if [ $failed_count -gt 0 ]; then
        log_error "Failed: $failed_count"
    fi
    echo ""
    
    if [ "$PROMPT_ONLY" = true ]; then
        log_info "Use without --prompt-only to execute these prompts with Claude Code"
    elif [ "$is_range_mode" = true ]; then
        if [ "$INTERACTIVE" = true ]; then
            log_info "All tasks completed in interactive mode."
        else
            log_info "All tasks completed in headless mode."
        fi
        log_info "Check GitHub for:"
        log_info "  - PR review comments posted via 'gh pr comment' (for PR reviews)"
        log_info "  - Issue audit comments and auto-closures (if complete)"
        log_info "  - New timestamped branches: issue-<number>-<timestamp> (implementation mode only)"
        log_info "  - Automated PRs created/updated (implementation mode only, when code changes exist)"
    else
        # Single task
        if [ "$INTERACTIVE" = true ]; then
            log_info "Single task completed in interactive mode."
        else
            log_info "Single task completed in headless mode."
        fi
        log_info "Check GitHub for results:"
        log_info "  - PR review comments (for PR reviews) or implementation PRs (for issues)"
    fi
}

# Run main function with all arguments
main "$@"
